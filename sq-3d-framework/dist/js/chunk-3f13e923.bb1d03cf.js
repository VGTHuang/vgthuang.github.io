(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-3f13e923"],{"08fd":function(e,r,t){var n={"./GlassFrontShader/F.glsl":"f430"};function o(e){var r=a(e);return t(r)}function a(e){if(!t.o(n,e)){var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}return n[e]}o.keys=function(){return Object.keys(n)},o.resolve=a,e.exports=o,o.id="08fd"},1148:function(e,r,t){"use strict";var n=t("da84"),o=t("5926"),a=t("577e"),i=t("1d80"),s=n.RangeError;e.exports=function(e){var r=a(i(this)),t="",n=o(e);if(n<0||n==1/0)throw s("Wrong number of repetitions");for(;n>0;(n>>>=1)&&(r+=r))1&n&&(t+=r);return t}},"38cf":function(e,r,t){var n=t("23e7"),o=t("1148");n({target:"String",proto:!0},{repeat:o})},5303:function(e,r,t){var n={"./GlassFrontShader/V.glsl":"c444"};function o(e){var r=a(e);return t(r)}function a(e){if(!t.o(n,e)){var r=new Error("Cannot find module '"+e+"'");throw r.code="MODULE_NOT_FOUND",r}return n[e]}o.keys=function(){return Object.keys(n)},o.resolve=a,e.exports=o,o.id="5303"},6189:function(e,r,t){},b7b6:function(e,r,t){"use strict";t.r(r);var n=function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("div",[t("div",{ref:"canvas-container",attrs:{id:"canvas-container"}})])},o=[],a=t("2b0e"),i=t("3835"),s=t("bee2"),c=t("d4ec"),l=t("ade3"),d=(t("d3b7"),t("159b"),t("38cf"),t("5a89")),v=t("4721");const f=new d["S"];function h(e,r,t,n,o,a){const i=2*Math.PI*o/4,s=Math.max(a-2*o,0),c=Math.PI/4;f.copy(r),f[n]=0,f.normalize();const l=.5*i/(i+s),d=1-f.angleTo(e)/c;if(1===Math.sign(f[t]))return d*l;{const e=s/(i+s);return e+l+l*(1-d)}}class u extends d["b"]{constructor(e=1,r=1,t=1,n=2,o=.1){if(n=2*n+1,o=Math.min(e/2,r/2,t/2,o),super(1,1,1,n,n,n),1===n)return;const a=this.toNonIndexed();this.index=null,this.attributes.position=a.attributes.position,this.attributes.normal=a.attributes.normal,this.attributes.uv=a.attributes.uv;const i=new d["S"],s=new d["S"],c=new d["S"](e,r,t).divideScalar(2).subScalar(o),l=this.attributes.position.array,v=this.attributes.normal.array,f=this.attributes.uv.array,u=l.length/6,g=new d["S"],p=.5/n;for(let d=0,b=0;d<l.length;d+=3,b+=2){i.fromArray(l,d),s.copy(i),s.x-=Math.sign(s.x)*p,s.y-=Math.sign(s.y)*p,s.z-=Math.sign(s.z)*p,s.normalize(),l[d+0]=c.x*Math.sign(i.x)+s.x*o,l[d+1]=c.y*Math.sign(i.y)+s.y*o,l[d+2]=c.z*Math.sign(i.z)+s.z*o,v[d+0]=s.x,v[d+1]=s.y,v[d+2]=s.z;const n=Math.floor(d/u);switch(n){case 0:g.set(1,0,0),f[b+0]=h(g,s,"z","y",o,t),f[b+1]=1-h(g,s,"y","z",o,r);break;case 1:g.set(-1,0,0),f[b+0]=1-h(g,s,"z","y",o,t),f[b+1]=1-h(g,s,"y","z",o,r);break;case 2:g.set(0,1,0),f[b+0]=1-h(g,s,"x","z",o,e),f[b+1]=h(g,s,"z","x",o,t);break;case 3:g.set(0,-1,0),f[b+0]=1-h(g,s,"x","z",o,e),f[b+1]=1-h(g,s,"z","x",o,t);break;case 4:g.set(0,0,1),f[b+0]=1-h(g,s,"x","y",o,e),f[b+1]=1-h(g,s,"y","x",o,r);break;case 5:g.set(0,0,-1),f[b+0]=h(g,s,"x","y",o,e),f[b+1]=1-h(g,s,"y","x",o,r);break}}}}function g(e){try{var r=t("5303")("./"+e+"/V.glsl"),n=t("08fd")("./"+e+"/F.glsl");return[r,n]}catch(o){return console.error("failed to fetch shader",o),["",""]}}var p,b,m,w,x,y,k,P=t("61d9"),C=Object(s["a"])((function e(r,t,n,o,a,s){if(Object(c["a"])(this,e),Object(l["a"])(this,"mesh",void 0),Object(l["a"])(this,"originalMaterial",void 0),Object(l["a"])(this,"refractionMaterial",void 0),this.mesh=r,this.mesh.material instanceof Array){this.originalMaterial=new Array;for(var v=0;v<this.mesh.material.length;v++)this.originalMaterial.push(this.mesh.material[v].clone())}else this.originalMaterial=this.mesh.material.clone();var f={resolution:{type:"v",value:t},tBackground:{type:"t",value:n},tBackDepth:{type:"t",value:o},refractionFactor:{type:"t",value:s},absorbColor:{type:"v",value:a}},h=g("GlassFrontShader"),u=Object(i["a"])(h,2),p=u[0],b=u[1];this.refractionMaterial=new d["K"]({vertexShader:p,fragmentShader:b,uniforms:f,side:d["p"]})})),R=function(){function e(r,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:512;Object(c["a"])(this,e),Object(l["a"])(this,"renderer",void 0),Object(l["a"])(this,"frontScene",void 0),Object(l["a"])(this,"scene",void 0),Object(l["a"])(this,"backdepthTexture",void 0),Object(l["a"])(this,"backRenderTarget",void 0),Object(l["a"])(this,"refractionObjectList",void 0),Object(l["a"])(this,"suResolution",void 0),this.scene=r,this.frontScene=new d["J"],this.renderer=t,this.backdepthTexture=new d["i"](n,n),this.backRenderTarget=new d["T"](p.offsetWidth*window.devicePixelRatio,p.offsetHeight*window.devicePixelRatio),this.backRenderTarget.depthBuffer=!0,this.backRenderTarget.depthTexture=this.backdepthTexture,this.backRenderTarget.depthTexture.type=d["Q"],this.frontScene.background=this.backRenderTarget.texture,this.refractionObjectList=[],this.suResolution=new d["R"](p.offsetWidth*window.devicePixelRatio,p.offsetHeight*window.devicePixelRatio)}return Object(s["a"])(e,[{key:"addRefractionMesh",value:function(e){var r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new d["e"](0),n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1.49;r&&(e.material=new d["z"]({color:"0x000000",transparent:!0,opacity:.3,metalness:.8,roughness:0,clearcoat:.2,side:d["a"]})),this.refractionObjectList.push(new C(e,this.suResolution,this.backRenderTarget.texture,this.backRenderTarget.depthTexture,t,n)),this.scene.add(e)}},{key:"onWindowResize",value:function(){this.suResolution.x=p.offsetWidth*window.devicePixelRatio,this.suResolution.y=p.offsetHeight*window.devicePixelRatio}},{key:"render",value:function(){var e=this;this.refractionObjectList.forEach((function(r){r.mesh.material=r.originalMaterial,e.scene.add(r.mesh)})),this.renderer.setRenderTarget(this.backRenderTarget),this.renderer.render(this.scene,m),this.refractionObjectList.forEach((function(r){r.mesh.material=r.refractionMaterial,e.frontScene.add(r.mesh)})),this.renderer.setRenderTarget(null),this.renderer.render(this.frontScene,m)}}]),e}();function _(e){p=e,m=new d["C"](45,window.innerWidth/window.innerHeight,1,5e3),m.position.set(30,20,200),m.lookAt(0,0,0),y=new d["J"],b=new d["U"]({antialias:!0,alpha:!0}),b.setClearColor(16777215),b.setPixelRatio(window.devicePixelRatio),b.setSize(window.innerWidth,window.innerHeight),p.appendChild(b.domElement),w=new v["a"](m,b.domElement),b.domElement.style.position="absolute",b.domElement.style.top="0px",b.domElement.style.left="0px",x=new P["Stats"],x.domElement.style.zIndex="100",p.appendChild(x.domElement);var r="./cube/",t=[r+"px.jpg",r+"nx.jpg",r+"py.jpg",r+"ny.jpg",r+"pz.jpg",r+"nz.jpg"],n=(new d["g"]).load(t);n.mapping=d["f"],y.background=n,y.environment=n;var o=new d["j"];o.position.x=300,o.position.y=200,o.position.z=100,y.add(o);var a=(new d["O"]).load("./checkerboard.jpg");a.wrapS=a.wrapT=d["H"],a.repeat.set(10,10);var i=new d["x"]({map:a,side:d["k"]}),s=new d["D"](1e3,1e3,1,1),c=new d["w"](s,i);c.position.y-=20.1,c.rotation.x=Math.PI/2,k=new R(y,b);var l=new d["w"](new u(40,40,40,5,5),new d["y"]({}));l.position.x-=40;var f=new d["w"](new d["L"](20),new d["y"]({})),h=new d["w"](new d["h"](20,20,80,36),new d["y"]({}));h.position.x+=40,h.position.y+=20,k.addRefractionMesh(l,!0,new d["e"](0),1.5),k.addRefractionMesh(f,!0,new d["e"](24576),1.5),k.addRefractionMesh(h,!0,new d["e"](1587),1.5);var g=new d["w"](new d["L"](20),new d["y"]({color:16711680}));g.position.copy(l.position),g.position.z-=50,y.add(g),window.addEventListener("resize",j),F()}function j(){m.aspect=window.innerWidth/window.innerHeight,m.updateProjectionMatrix(),k.onWindowResize(),b.setSize(window.innerWidth,window.innerHeight)}function F(){requestAnimationFrame(F),T(),w.update(),x.update()}function T(){k.render()}var z=a["a"].extend({mounted:function(){this.$refs["canvas-container"]instanceof HTMLElement&&_(this.$refs["canvas-container"])}}),M=z,D=(t("b7e4"),t("2877")),O=Object(D["a"])(M,n,o,!1,null,"bb4bef88",null);r["default"]=O.exports},b7e4:function(e,r,t){"use strict";t("6189")},c444:function(e,r){e.exports="varying vec2 vUv;\r\nvarying vec3 vNormal;\r\nvarying vec3 vCameraPosition;\r\nvarying vec4 vWorldPosition;\r\nvarying mat4 vProjectionMatrix;\r\n// varying vec3 vRefract;\r\n// varying vec2 vRefractOffset;\r\n\r\n\r\nvoid main() {\r\n    vWorldPosition = modelMatrix * vec4( position, 1.0 );\r\n    vec4 mvPosition = viewMatrix * vWorldPosition;\r\n    gl_Position = projectionMatrix * mvPosition;\r\n    vUv = uv;\r\n\r\n    vNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\r\n    vCameraPosition = cameraPosition;\r\n\r\n    vProjectionMatrix = projectionMatrix * modelViewMatrix;\r\n}\r\n"},f430:function(e,r){e.exports="uniform vec2 resolution;\r\nuniform sampler2D tBackground;\r\nuniform sampler2D tBackDepth;\r\nuniform vec3 absorbColor;\r\nuniform float refractionFactor;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vNormal;\r\nvarying vec3 vCameraPosition;\r\nvarying vec4 vWorldPosition;\r\nvarying mat4 vProjectionMatrix;\r\n\r\nfloat near = 0.1;\r\nfloat far  = 5000.0;\r\n\r\nfloat LinearizeDepth(float depth) \r\n{\r\n    float z = depth * 2.0 - 1.0; // back to NDC \r\n    return (2.0 * near * far) / (far + near - z * (far - near));\t\r\n}\r\n\r\nvoid main() {\r\n\r\n    float backDepth = float(texture2D( tBackDepth, vec2( gl_FragCoord.x / resolution.x, gl_FragCoord.y / resolution.y ) ).x);\r\n    float frontDepth = gl_FragCoord.z;\r\n\r\n    float backDepthlinear = LinearizeDepth(backDepth);\r\n    float frontDepthlinear = LinearizeDepth(frontDepth);\r\n    \r\n    float backToFrontDepth = backDepthlinear - frontDepthlinear;\r\n    if (backToFrontDepth <= 0.0) {\r\n        // discard;\r\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n        return;\r\n    }\r\n    // backToFrontDepth *= 10.0;\r\n    \r\n    vec3 vCameraRay = vWorldPosition.xyz / vWorldPosition.w - vCameraPosition;\r\n    vCameraRay = normalize(vCameraRay);\r\n    vec3 vRefract = refract( vCameraRay, vNormal, 1.0 / refractionFactor );\r\n    vec4 vOriginalPos = vWorldPosition + vec4(vCameraRay, 0.0);\r\n    vec4 vRefractedPos = vWorldPosition + vec4(vRefract, 0.0);\r\n    // vRefractedPos = vOriginalPos; //vWorldPosition + vec4(vRefract, 0.0);\r\n    vec4 vOriginalProjectedPos = vProjectionMatrix * vOriginalPos;\r\n    vec4 vRefractedProjectedPos = vProjectionMatrix * vRefractedPos;\r\n    vec2 offset = normalize(vRefractedProjectedPos - vOriginalProjectedPos).xy;\r\n    offset = normalize(offset);\r\n\r\n    // snell's law\r\n    float cosTheta1 = dot(vCameraRay, vNormal);\r\n    float sinTheta1 = 1.0 - cosTheta1 * cosTheta1;\r\n    float sinTheta2 = sinTheta1 / refractionFactor;\r\n    float theta2 = asin(sinTheta2);\r\n    offset *= sinTheta2;\r\n    offset *= 50.0;\r\n\r\n    float samplePointX_r = (gl_FragCoord.x + backToFrontDepth * offset.x * 0.9) / resolution.x;\r\n    float samplePointY_r = (gl_FragCoord.y + backToFrontDepth * offset.y * 0.9) / resolution.y;\r\n\r\n    float samplePointX_g = (gl_FragCoord.x + backToFrontDepth * offset.x * 0.95) / resolution.x;\r\n    float samplePointY_g = (gl_FragCoord.y + backToFrontDepth * offset.y * 0.95) / resolution.y;\r\n\r\n    float samplePointX_b = (gl_FragCoord.x + backToFrontDepth * offset.x) / resolution.x;\r\n    float samplePointY_b = (gl_FragCoord.y + backToFrontDepth * offset.y) / resolution.y;\r\n    \r\n    float backColor_r = texture2D( tBackground, vec2( samplePointX_r, samplePointY_r ) ).x;\r\n    float backColor_g = texture2D( tBackground, vec2( samplePointX_g, samplePointY_g ) ).y;\r\n    float backColor_b = texture2D( tBackground, vec2( samplePointX_b, samplePointY_b ) ).z;\r\n\r\n    vec3 backColor = vec3(backColor_r, backColor_g, backColor_b);\r\n    vec3 absorbColor = absorbColor * backToFrontDepth * 0.2;\r\n    // vec4 vNewSample = projectionMatrix * (vec4(vRefract, 0.0) + worldPosition);\r\n    // vRefractOffset = vNewSample.xy / vNewSample.w;\r\n    // // vNormal = normal;\r\n    // vec3 vRefractOffsetT = vRefract + 0.5;\r\n    // gl_FragColor = vec4(backColor * 0.5 + vNormal * 0.2 + depthColor * 0.1, 1.0);\r\n    gl_FragColor = vec4(backColor + absorbColor, 1.0);\r\n    // gl_FragColor = vec4(backColor, 1.0);\r\n    // gl_FragColor = vec4(vec3(backToFrontDepth) * 100.0, 1.0);\r\n    // gl_FragColor = vec4(offset.xy / offset.w + 0.5, 0.0, 1.0);\r\n    // gl_FragColor = vec4(vec3(theta2), 1.0);\r\n\r\n    // gl_FragColor = vec4(vec3(gl_FragCoord.z / gl_FragCoord.w - fragColor2.x * 10.0) / 2000.0, 1.0);\r\n    // gl_FragColor = vec4(backToFrontDepth, 0.0, 0.0, 1.0);\r\n}"}}]);
//# sourceMappingURL=chunk-3f13e923.bb1d03cf.js.map