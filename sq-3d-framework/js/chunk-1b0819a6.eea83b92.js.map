{"version":3,"sources":["webpack:///./src/scripts/ThreeRealisticRefraction sync ^\\.\\/.*\\/F\\.glsl$","webpack:///./node_modules/core-js/internals/string-repeat.js","webpack:///./node_modules/core-js/modules/es.string.repeat.js","webpack:///./src/scripts/ThreeRealisticRefraction sync ^\\.\\/.*\\/V\\.glsl$","webpack:///./node_modules/three/examples/jsm/geometries/RoundedBoxGeometry.js","webpack:///./src/scripts/ThreeRealisticRefraction/ShaderLoader.ts","webpack:///./src/scripts/ThreeRealisticRefraction/ThreeRealisticRefraction.ts","webpack:///./src/views/ThreeGlassRefractionTest.vue?b7fb","webpack:///./src/views/ThreeGlassRefractionTest.vue","webpack:///./src/views/ThreeGlassRefractionTest.vue?9e0e","webpack:///./src/views/ThreeGlassRefractionTest.vue?615f","webpack:///./src/views/ThreeGlassRefractionTest.vue?a1b8","webpack:///./src/scripts/ThreeRealisticRefraction/GlassFrontShader/V.glsl","webpack:///./src/scripts/ThreeRealisticRefraction/GlassFrontShader/F.glsl"],"names":["map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","module","exports","global","toIntegerOrInfinity","toString","requireObjectCoercible","RangeError","count","str","this","result","n","Infinity","$","repeat","target","proto","_tempNormal","getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","halfArc","copy","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","lenUv","RoundedBoxGeometry","width","height","depth","segments","min","super","geometry2","toNonIndexed","index","attributes","position","uv","box","divideScalar","subScalar","positions","array","normals","uvs","faceTris","length","halfSegmentSize","i","j","fromArray","x","y","z","side","floor","set","loadShader","shaderName","vertexShader","fragShader","err","console","error","controls","stats","rm","scene","mesh","suResolution","suBackground","suDepth","absorbColor","suRefractionFactor","material","Array","originalMaterial","push","clone","refractionMaterialUniforms","type","value","environment","glassFrontVS","glassFrontFS","refractionMaterial","fragmentShader","uniforms","backgroundScene","container","renderer","camera","backDepthTextureSize","frontScene","backdepthTexture","backRenderTarget","offsetWidth","window","devicePixelRatio","offsetHeight","depthBuffer","depthTexture","background","texture","refractionObjectList","setDefaultBacksideMaterial","refractionFactor","color","transparent","opacity","metalness","roughness","clearcoat","add","forEach","refObj","setRenderTarget","render","initScene","_container","innerWidth","innerHeight","lookAt","antialias","alpha","setClearColor","setPixelRatio","setSize","appendChild","domElement","OrbitControls","style","top","left","zIndex","r","urls","textureCube","load","mapping","light","floorTexture","wrapS","wrapT","floorMaterial","floorGeometry","rotation","glassMesh1","glassMesh2","glassMesh3","addRefractionMesh","ballMesh","addEventListener","onWindowResize","animate","aspect","updateProjectionMatrix","requestAnimationFrame","update","_vm","_h","$createElement","_c","_self","ref","attrs","staticRenderFns","extend","mounted","$refs","HTMLElement","component"],"mappings":"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","file":"js/chunk-1b0819a6.eea83b92.js","sourcesContent":["var map = {\n\t\"./GlassFrontShader/F.glsl\": \"f430\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"08fd\";","'use strict';\nvar global = require('../internals/global');\nvar toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\nvar toString = require('../internals/to-string');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nvar RangeError = global.RangeError;\n\n// `String.prototype.repeat` method implementation\n// https://tc39.es/ecma262/#sec-string.prototype.repeat\nmodule.exports = function repeat(count) {\n  var str = toString(requireObjectCoercible(this));\n  var result = '';\n  var n = toIntegerOrInfinity(count);\n  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;\n  return result;\n};\n","var $ = require('../internals/export');\nvar repeat = require('../internals/string-repeat');\n\n// `String.prototype.repeat` method\n// https://tc39.es/ecma262/#sec-string.prototype.repeat\n$({ target: 'String', proto: true }, {\n  repeat: repeat\n});\n","var map = {\n\t\"./GlassFrontShader/V.glsl\": \"c444\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"5303\";","import {\n\tBoxGeometry,\n\tVector3\n} from 'three';\n\nconst _tempNormal = new Vector3();\n\nfunction getUv( faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength ) {\n\n\tconst totArcLength = 2 * Math.PI * radius / 4;\n\n\t// length of the planes between the arcs on each axis\n\tconst centerLength = Math.max( sideLength - 2 * radius, 0 );\n\tconst halfArc = Math.PI / 4;\n\n\t// Get the vector projected onto the Y plane\n\t_tempNormal.copy( normal );\n\t_tempNormal[ projectionAxis ] = 0;\n\t_tempNormal.normalize();\n\n\t// total amount of UV space alloted to a single arc\n\tconst arcUvRatio = 0.5 * totArcLength / ( totArcLength + centerLength );\n\n\t// the distance along one arc the point is at\n\tconst arcAngleRatio = 1.0 - ( _tempNormal.angleTo( faceDirVector ) / halfArc );\n\n\tif ( Math.sign( _tempNormal[ uvAxis ] ) === 1 ) {\n\n\t\treturn arcAngleRatio * arcUvRatio;\n\n\t} else {\n\n\t\t// total amount of UV space alloted to the plane between the arcs\n\t\tconst lenUv = centerLength / ( totArcLength + centerLength );\n\t\treturn lenUv + arcUvRatio + arcUvRatio * ( 1.0 - arcAngleRatio );\n\n\t}\n\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, segments = 2, radius = 0.1 ) {\n\n\t\t// ensure segments is odd so we have a plane connecting the rounded corners\n\t\tsegments = segments * 2 + 1;\n\n\t\t// ensure radius isn't bigger than shortest side\n\t\tradius = Math.min( width / 2, height / 2, depth / 2, radius );\n\n\t\tsuper( 1, 1, 1, segments, segments, segments );\n\n\t\t// if we just have one segment we're the same as a regular box\n\t\tif ( segments === 1 ) return;\n\n\t\tconst geometry2 = this.toNonIndexed();\n\n\t\tthis.index = null;\n\t\tthis.attributes.position = geometry2.attributes.position;\n\t\tthis.attributes.normal = geometry2.attributes.normal;\n\t\tthis.attributes.uv = geometry2.attributes.uv;\n\n\t\t//\n\n\t\tconst position = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst box = new Vector3( width, height, depth ).divideScalar( 2 ).subScalar( radius );\n\n\t\tconst positions = this.attributes.position.array;\n\t\tconst normals = this.attributes.normal.array;\n\t\tconst uvs = this.attributes.uv.array;\n\n\t\tconst faceTris = positions.length / 6;\n\t\tconst faceDirVector = new Vector3();\n\t\tconst halfSegmentSize = 0.5 / segments;\n\n\t\tfor ( let i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tposition.fromArray( positions, i );\n\t\t\tnormal.copy( position );\n\t\t\tnormal.x -= Math.sign( normal.x ) * halfSegmentSize;\n\t\t\tnormal.y -= Math.sign( normal.y ) * halfSegmentSize;\n\t\t\tnormal.z -= Math.sign( normal.z ) * halfSegmentSize;\n\t\t\tnormal.normalize();\n\n\t\t\tpositions[ i + 0 ] = box.x * Math.sign( position.x ) + normal.x * radius;\n\t\t\tpositions[ i + 1 ] = box.y * Math.sign( position.y ) + normal.y * radius;\n\t\t\tpositions[ i + 2 ] = box.z * Math.sign( position.z ) + normal.z * radius;\n\n\t\t\tnormals[ i + 0 ] = normal.x;\n\t\t\tnormals[ i + 1 ] = normal.y;\n\t\t\tnormals[ i + 2 ] = normal.z;\n\n\t\t\tconst side = Math.floor( i / faceTris );\n\n\t\t\tswitch ( side ) {\n\n\t\t\t\tcase 0: // right\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // left\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( - 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // top\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // bottom\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, - 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4: // front\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, 1 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5: // back\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, - 1 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { RoundedBoxGeometry };\n","export function loadShader(shaderName: string): Array<string> {\r\n    try {\r\n        var vertexShader = require('./' + shaderName + '/V.glsl')\r\n        var fragShader = require('./' + shaderName + '/F.glsl')\r\n        return [vertexShader, fragShader]\r\n    }\r\n    catch(err) {\r\n        console.error('failed to fetch shader', err)\r\n        return ['', '']\r\n    }\r\n}","import * as THREE from 'three'\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer'\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass'\r\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass'\r\nimport { FXAAShader  } from 'three/examples/jsm/shaders/FXAAShader'\r\nimport { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry'\r\n// import { ClearPass } from 'three/examples/jsm/postprocessing/ClearPass'\r\n// import FresnelShader from './FresnelShader'\r\nimport { loadShader } from './ShaderLoader'\r\nimport { Stats } from 'three-stats'\r\nimport { ShaderMaterial } from 'three'\r\n\r\nclass RefractionObject {\r\n    mesh: THREE.Mesh\r\n    originalMaterial: THREE.Material | THREE.Material[]\r\n    refractionMaterial: THREE.ShaderMaterial\r\n    // suResolution: THREE.Vector2\r\n    // suBackground: THREE.Texture\r\n    // suDepth: THREE.DepthTexture\r\n    constructor(scene: THREE.Scene, mesh: THREE.Mesh, suResolution: THREE.Vector2, suBackground: THREE.Texture, suDepth: THREE.DepthTexture,\r\n        absorbColor: THREE.Color, suRefractionFactor: number) {\r\n        this.mesh = mesh\r\n        // copy material\r\n        if (this.mesh.material instanceof Array) {\r\n            this.originalMaterial = new Array<THREE.Material>()\r\n            for (let i = 0; i < this.mesh.material.length; i++) {\r\n                this.originalMaterial.push(this.mesh.material[i].clone())\r\n            }\r\n        }\r\n        else {\r\n            this.originalMaterial = this.mesh.material.clone()\r\n        }\r\n        var refractionMaterialUniforms = {\r\n            \"resolution\": { type: \"v\", value: suResolution },\r\n            \"tBackground\":    { type: \"t\", value: suBackground },\r\n            \"tBackDepth\": { type: \"t\", value: suDepth },\r\n            \"tSkybox\": { type: \"t\", value: scene.environment },\r\n            \"refractionFactor\": { type: \"t\", value: suRefractionFactor },\r\n            \"absorbColor\": { type: \"v\", value: absorbColor }\r\n        }\r\n        var [glassFrontVS, glassFrontFS] = loadShader('GlassFrontShader')\r\n        this.refractionMaterial = new ShaderMaterial({\r\n            vertexShader:   glassFrontVS,\r\n            fragmentShader: glassFrontFS,\r\n            uniforms: refractionMaterialUniforms,\r\n            // depthTest: false,\r\n            // stencilWrite: true,\r\n            // stencilRef: 999,\r\n            // stencilZPass: THREE.ReplaceStencilOp,  // write if the depth buffer test passes\r\n            side: THREE.FrontSide\r\n        })\r\n    }\r\n}\r\n\r\nexport class RefractionManager {\r\n    container: HTMLElement\r\n    backgroundScene: THREE.Scene\r\n    scene: THREE.Scene\r\n    renderer: THREE.WebGLRenderer\r\n    camera: THREE.PerspectiveCamera\r\n\r\n    frontScene: THREE.Scene\r\n\r\n    backdepthTexture: THREE.DepthTexture\r\n    backRenderTarget: THREE.WebGLRenderTarget\r\n\r\n    refractionObjectList: Array<RefractionObject>\r\n\r\n    suResolution: THREE.Vector2\r\n\r\n    constructor(\r\n        backgroundScene: THREE.Scene, container: HTMLElement, renderer: THREE.WebGLRenderer, camera: THREE.PerspectiveCamera,\r\n        backDepthTextureSize: number = 512\r\n    ) {\r\n        this.container = container\r\n        this.backgroundScene = backgroundScene\r\n        this.scene = new THREE.Scene()\r\n        this.renderer = renderer\r\n        this.camera = camera\r\n\r\n        this.frontScene = new THREE.Scene()\r\n        this.backdepthTexture = new THREE.DepthTexture(\r\n            backDepthTextureSize, backDepthTextureSize,\r\n            THREE.FloatType\r\n        )\r\n        this.backRenderTarget = new THREE.WebGLRenderTarget(\r\n            this.container.offsetWidth * window.devicePixelRatio,\r\n            this.container.offsetHeight * window.devicePixelRatio,\r\n            \r\n        )\r\n        this.backRenderTarget.depthBuffer = true;\r\n        this.backRenderTarget.depthTexture = this.backdepthTexture;\r\n        this.backRenderTarget.depthTexture.type = THREE.UnsignedIntType;\r\n        this.frontScene.background = this.backRenderTarget.texture\r\n        this.refractionObjectList = []\r\n        this.suResolution = new THREE.Vector2(\r\n            this.container.offsetWidth * window.devicePixelRatio,\r\n            this.container.offsetHeight * window.devicePixelRatio\r\n        )\r\n\r\n    }\r\n\r\n    addRefractionMesh(mesh: THREE.Mesh, setDefaultBacksideMaterial: boolean = true,\r\n        absorbColor: THREE.Color = new THREE.Color(0x000000), refractionFactor: number = 1.49) {\r\n        if (setDefaultBacksideMaterial) {\r\n            mesh.material = new THREE.MeshPhysicalMaterial({\r\n                // color: 0x00000000,\r\n                color: new THREE.Color(0x000000),\r\n                transparent: true,\r\n                opacity: 0.3,\r\n                metalness: 0.8,\r\n                roughness: 0.0,\r\n                clearcoat: 0.2,\r\n                side: THREE.BackSide\r\n                // colorWrite: false\r\n            })\r\n        }\r\n        this.refractionObjectList.push(new RefractionObject(\r\n            this.backgroundScene,\r\n            mesh,\r\n            this.suResolution,\r\n            this.backRenderTarget.texture,\r\n            this.backRenderTarget.depthTexture,\r\n            absorbColor,\r\n            refractionFactor\r\n        ))\r\n        this.scene.add(mesh)\r\n    }\r\n\r\n    onWindowResize() {\r\n        this.suResolution.x = this.container.offsetWidth * window.devicePixelRatio\r\n        this.suResolution.y = this.container.offsetHeight * window.devicePixelRatio\r\n    }\r\n\r\n    render() {\r\n        this.refractionObjectList.forEach(refObj => {\r\n            refObj.mesh.material = refObj.originalMaterial\r\n            this.scene.add(refObj.mesh)\r\n        })\r\n        this.renderer.setRenderTarget(this.backRenderTarget)\r\n        this.renderer.render(this.scene, this.camera)\r\n        \r\n        this.refractionObjectList.forEach(refObj => {\r\n            refObj.mesh.material = refObj.refractionMaterial\r\n            this.frontScene.add(refObj.mesh)\r\n        })\r\n        this.renderer.setRenderTarget(null)\r\n        this.renderer.render(this.frontScene, this.camera)\r\n    }\r\n}\r\n\r\nvar container: HTMLElement\r\nvar renderer: THREE.WebGLRenderer, camera: THREE.PerspectiveCamera, controls: OrbitControls\r\nvar stats: Stats\r\nvar scene: THREE.Scene\r\nvar rm: RefractionManager\r\n\r\nexport function initScene(_container: HTMLElement) {\r\n    container = _container\r\n    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 5000 )\r\n    camera.position.set(30, 20, 200)\r\n    camera.lookAt(0, 0, 0)\r\n\r\n    scene = new THREE.Scene()\r\n\r\n    renderer = new THREE.WebGLRenderer( {antialias: true, alpha: true} )\r\n    \r\n    renderer.setClearColor( 0xffffff )\r\n    renderer.setPixelRatio( window.devicePixelRatio )\r\n    renderer.setSize(window.innerWidth, window.innerHeight)\r\n    container.appendChild( renderer.domElement )\r\n    controls = new OrbitControls(camera, container)\r\n    container.style.position = 'absolute'\r\n    container.style.top = '0px'\r\n    container.style.left = '0px'\r\n    stats = new Stats()\r\n    stats.domElement.style.zIndex = '100'\r\n    container.appendChild( stats.domElement )\r\n\r\n    // set background\r\n    const r = './cube/'\r\n\r\n    const urls = [\r\n        r + 'px.jpg', r + 'nx.jpg',\r\n        r + 'py.jpg', r + 'ny.jpg',\r\n        r + 'pz.jpg', r + 'nz.jpg'\r\n    ]\r\n\r\n    const textureCube = new THREE.CubeTextureLoader().load( urls )\r\n    textureCube.mapping = THREE.CubeRefractionMapping\r\n\r\n    scene.background = textureCube\r\n    scene.environment = textureCube\r\n    \r\n    // set light\r\n    var light = new THREE.DirectionalLight()\r\n    light.position.x = 300\r\n    light.position.y = 200\r\n    light.position.z = 100\r\n    scene.add(light)\r\n\r\n    // set floor\r\n    var floorTexture = new THREE.TextureLoader().load( './checkerboard.jpg' )\r\n\tfloorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping\r\n\tfloorTexture.repeat.set( 10, 10 )\r\n    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } )\r\n\tvar floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1)\r\n\tvar floor = new THREE.Mesh(floorGeometry, floorMaterial)\r\n\tfloor.position.y -= 20.1\r\n\tfloor.rotation.x = Math.PI / 2\r\n    // scene.add(floor)\r\n\r\n    rm = new RefractionManager(scene, container, renderer, camera)\r\n\r\n    var glassMesh1 = new THREE.Mesh(\r\n        new RoundedBoxGeometry(40, 40, 40, 5, 5),\r\n        new THREE.MeshPhongMaterial({})\r\n    )\r\n    glassMesh1.position.x -= 40\r\n    var glassMesh2 = new THREE.Mesh(\r\n        new THREE.SphereGeometry( 20 ),\r\n        new THREE.MeshPhongMaterial({})\r\n    )\r\n    var glassMesh3 = new THREE.Mesh(\r\n        new THREE.CylinderGeometry( 20, 20, 80, 36 ),\r\n        new THREE.MeshPhongMaterial({})\r\n    )\r\n    glassMesh3.position.x += 40\r\n    glassMesh3.position.y += 20\r\n\r\n    rm.addRefractionMesh(glassMesh1, true, new THREE.Color(0x000000), 1.5)\r\n    rm.addRefractionMesh(glassMesh2, true, new THREE.Color(0x006000), 1.5)\r\n    rm.addRefractionMesh(glassMesh3, true, new THREE.Color(0x000633), 1.5)\r\n\r\n    // add a few spheres\r\n    var ballMesh = new THREE.Mesh(\r\n        new THREE.SphereGeometry( 20 ),\r\n        new THREE.MeshPhongMaterial({\r\n            color: 0xff0000\r\n        })\r\n    )\r\n    ballMesh.position.copy(glassMesh1.position)\r\n    ballMesh.position.z -= 50\r\n    scene.add(ballMesh)\r\n\r\n    window.addEventListener( 'resize', onWindowResize )\r\n    animate()\r\n\r\n}\r\n\r\nfunction onWindowResize() {\r\n\r\n    camera.aspect = window.innerWidth / window.innerHeight\r\n    camera.updateProjectionMatrix()\r\n    rm.onWindowResize()\r\n    renderer.setSize( window.innerWidth, window.innerHeight )\r\n\r\n}\r\n\r\nfunction animate() {\r\n    requestAnimationFrame( animate )\r\n    render()\r\n    controls.update()\r\n    stats.update()\r\n}\r\n\r\nfunction render()\r\n{\r\n    rm.render()\r\n}","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{ref:\"canvas-container\",attrs:{\"id\":\"canvas-container\"}})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\r\nimport * as THREE from 'three'\r\nimport Vue from 'vue'\r\nimport * as ThreeGlassRefraction from '../scripts/ThreeRealisticRefraction/ThreeRealisticRefraction'\r\n\r\nexport default Vue.extend({\r\n    mounted() {\r\n        if (this.$refs['canvas-container'] instanceof HTMLElement) {\r\n            ThreeGlassRefraction.initScene(this.$refs['canvas-container'])\r\n        }\r\n    }\r\n})\r\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--15-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--15-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ThreeGlassRefractionTest.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--15-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--15-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ThreeGlassRefractionTest.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ThreeGlassRefractionTest.vue?vue&type=template&id=bb4bef88&scoped=true&\"\nimport script from \"./ThreeGlassRefractionTest.vue?vue&type=script&lang=ts&\"\nexport * from \"./ThreeGlassRefractionTest.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./ThreeGlassRefractionTest.vue?vue&type=style&index=0&id=bb4bef88&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"bb4bef88\",\n  null\n  \n)\n\nexport default component.exports","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--7-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ThreeGlassRefractionTest.vue?vue&type=style&index=0&id=bb4bef88&scoped=true&lang=css&\"","module.exports = \"varying vec2 vUv;\\r\\nvarying vec3 vNormal;\\r\\nvarying vec3 vCameraPosition;\\r\\nvarying vec4 vWorldPosition;\\r\\nvarying mat4 vProjectionMatrix;\\r\\n// varying vec3 vRefract;\\r\\n// varying vec2 vRefractOffset;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n    vWorldPosition = modelMatrix * vec4( position, 1.0 );\\r\\n    vec4 mvPosition = viewMatrix * vWorldPosition;\\r\\n    gl_Position = projectionMatrix * mvPosition;\\r\\n    vUv = uv;\\r\\n\\r\\n    vNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\\r\\n    vCameraPosition = cameraPosition;\\r\\n\\r\\n    vProjectionMatrix = projectionMatrix * modelViewMatrix;\\r\\n}\\r\\n\"","module.exports = \"uniform vec2 resolution;\\r\\nuniform sampler2D tBackground;\\r\\nuniform sampler2D tBackDepth;\\r\\nuniform samplerCube tSkybox;\\r\\nuniform vec3 absorbColor;\\r\\nuniform float refractionFactor;\\r\\n\\r\\nvarying vec2 vUv;\\r\\nvarying vec3 vNormal;\\r\\nvarying vec3 vCameraPosition;\\r\\nvarying vec4 vWorldPosition;\\r\\nvarying mat4 vProjectionMatrix;\\r\\n\\r\\nfloat near = 0.1;\\r\\nfloat far  = 5000.0;\\r\\n\\r\\nfloat LinearizeDepth(float depth) \\r\\n{\\r\\n    float z = depth * 2.0 - 1.0; // back to NDC \\r\\n    return (2.0 * near * far) / (far + near - z * (far - near));\\t\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n    float backDepth = float(texture2D( tBackDepth, vec2( gl_FragCoord.x / resolution.x, gl_FragCoord.y / resolution.y ) ).x);\\r\\n    float frontDepth = gl_FragCoord.z;\\r\\n\\r\\n    float backDepthlinear = LinearizeDepth(backDepth);\\r\\n    float frontDepthlinear = LinearizeDepth(frontDepth);\\r\\n    \\r\\n    float backToFrontDepth = backDepthlinear - frontDepthlinear;\\r\\n    // backToFrontDepth *= 0.07;\\r\\n    \\r\\n    vec3 vCameraRay = vWorldPosition.xyz / vWorldPosition.w - vCameraPosition;\\r\\n    vCameraRay = normalize(vCameraRay);\\r\\n    vec3 vRefract = refract( vCameraRay, vNormal, 1.0 / refractionFactor );\\r\\n    vec4 vOriginalPos = vWorldPosition + vec4(vCameraRay, 0.0);\\r\\n    vec4 vRefractedPos = vWorldPosition + vec4(vRefract, 0.0);\\r\\n    // vRefractedPos = vOriginalPos; //vWorldPosition + vec4(vRefract, 0.0);\\r\\n    vec4 vOriginalProjectedPos = vProjectionMatrix * vOriginalPos;\\r\\n    vec4 vRefractedProjectedPos = vProjectionMatrix * vRefractedPos;\\r\\n    vec2 offset = normalize(vRefractedProjectedPos - vOriginalProjectedPos).xy;\\r\\n    offset = normalize(offset);\\r\\n\\r\\n    // reflect\\r\\n    vec3 vReflect = reflect( vCameraRay, vNormal );\\r\\n    vec3 refCol = vec3(textureCube(tSkybox, vReflect));\\r\\n\\r\\n    // snell's law\\r\\n    float cosTheta1 = dot(vCameraRay, vNormal);\\r\\n    float sinTheta1 = 1.0 - cosTheta1 * cosTheta1;\\r\\n    float sinTheta2 = sinTheta1 / refractionFactor;\\r\\n    float theta2 = asin(sinTheta2);\\r\\n    offset *= sinTheta2;\\r\\n    offset *= 50.0;\\r\\n\\r\\n    float samplePointX_r = (gl_FragCoord.x + backToFrontDepth * offset.x * 0.9) / resolution.x;\\r\\n    float samplePointY_r = (gl_FragCoord.y + backToFrontDepth * offset.y * 0.9) / resolution.y;\\r\\n\\r\\n    float samplePointX_g = (gl_FragCoord.x + backToFrontDepth * offset.x * 0.95) / resolution.x;\\r\\n    float samplePointY_g = (gl_FragCoord.y + backToFrontDepth * offset.y * 0.95) / resolution.y;\\r\\n\\r\\n    float samplePointX_b = (gl_FragCoord.x + backToFrontDepth * offset.x) / resolution.x;\\r\\n    float samplePointY_b = (gl_FragCoord.y + backToFrontDepth * offset.y) / resolution.y;\\r\\n    \\r\\n    float backColor_r = texture2D( tBackground, vec2( samplePointX_r, samplePointY_r ) * 1.0 ).x;\\r\\n    float backColor_g = texture2D( tBackground, vec2( samplePointX_g, samplePointY_g ) * 1.0 ).y;\\r\\n    float backColor_b = texture2D( tBackground, vec2( samplePointX_b, samplePointY_b ) * 1.0 ).z;\\r\\n\\r\\n    vec3 backColor = vec3(backColor_r, backColor_g, backColor_b);\\r\\n    vec3 absorbColor = absorbColor * backToFrontDepth * 0.2;\\r\\n\\r\\n    // backColor = texture2D( tBackground, vec2( (gl_FragCoord.x + backToFrontDepth * offset.x) / resolution.x, (gl_FragCoord.y + backToFrontDepth * offset.y) / resolution.y ) * 1.0 ).xyz;\\r\\n\\r\\n    // gl_FragColor = vec4(refCol, 1.0);\\r\\n    float reflectionCoeff = 0.5 * pow(sinTheta1, 4.0);\\r\\n    // reflectionCoeff = 1.0;\\r\\n    gl_FragColor = vec4((1.0 - reflectionCoeff) * (backColor + absorbColor) + reflectionCoeff * refCol, 1.0);\\r\\n    // gl_FragColor = vec4(vec3(backDepthlinear*0.01), 1.0);\\r\\n}\""],"sourceRoot":""}