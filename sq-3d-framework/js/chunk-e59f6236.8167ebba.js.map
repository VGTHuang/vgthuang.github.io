{"version":3,"sources":["webpack:///./src/scripts/ThreeRealisticRefraction sync ^\\.\\/.*\\/F\\.glsl$","webpack:///./node_modules/core-js/internals/string-repeat.js","webpack:///./node_modules/three/examples/jsm/loaders/TDSLoader.js","webpack:///./node_modules/core-js/modules/es.string.repeat.js","webpack:///./src/scripts/ThreeRealisticRefraction sync ^\\.\\/.*\\/V\\.glsl$","webpack:///./node_modules/three/examples/jsm/geometries/RoundedBoxGeometry.js","webpack:///./src/scripts/ThreeRealisticRefraction/ShaderLoader.ts","webpack:///./src/scripts/ThreeRealisticRefraction/ThreeRealisticRefraction.ts","webpack:///./src/scripts/ThreeRealisticRefraction/GlassFrontShader/V.glsl","webpack:///./src/scripts/ThreeRealisticRefraction/GlassFrontShader/F.glsl","webpack:///./node_modules/three/examples/jsm/objects/Reflector.js","webpack:///./src/scripts/Three/SQWater.ts"],"names":["map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","module","exports","global","toIntegerOrInfinity","toString","requireObjectCoercible","RangeError","count","str","this","result","n","Infinity","TDSLoader","manager","super","debug","group","materials","meshes","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","data","parse","console","error","itemError","arraybuffer","readFile","i","length","add","DataView","chunk","Chunk","debugMessage","MLIBMAGIC","CMAGIC","M3DMAGIC","next","readChunk","M3D_VERSION","version","readDWord","MDATA","readMeshData","hexId","MESH_VERSION","MASTER_SCALE","scale","readFloat","set","NAMED_OBJECT","readNamedObject","MAT_ENTRY","readMaterialEntry","name","readString","N_TRI_OBJECT","mesh","readMesh","push","material","MAT_NAME","MAT_WIRE","wireframe","MAT_WIRE_SIZE","value","readByte","wireframeLinewidth","MAT_TWO_SIDE","side","MAT_ADDITIVE","blending","MAT_DIFFUSE","color","readColor","MAT_SPECULAR","specular","MAT_AMBIENT","MAT_SHININESS","shininess","readPercentage","MAT_TRANSPARENCY","transparency","opacity","transparent","MAT_TEXMAP","readMap","MAT_BUMPMAP","bumpMap","MAT_OPACMAP","alphaMap","MAT_SPECMAP","specularMap","geometry","POINT_ARRAY","points","readWord","vertices","setAttribute","FACE_ARRAY","readFaceArray","TEX_VERTS","texels","uvs","MESH_MATRIX","values","matrix","elements","transpose","inverse","copy","invert","applyMatrix4","decompose","position","quaternion","computeVertexNormals","faces","index","setIndex","materialIndex","start","endOfChunk","subchunk","MSH_MAT_GROUP","readMaterialGroup","addGroup","Array","isArray","undefined","texture","resourcePath","setCrossOrigin","crossOrigin","MAT_MAPNAME","MAT_MAP_UOFFSET","offset","x","MAT_MAP_VOFFSET","y","MAT_MAP_USCALE","repeat","MAT_MAP_VSCALE","numFaces","subChunk","COLOR_24","LIN_COLOR_24","r","g","b","setRGB","COLOR_F","LIN_COLOR_F","INT_PERCENTAGE","readShort","FLOAT_PERCENTAGE","message","log","Function","size","end","byteLength","v","getUint8","getFloat32","getInt32","getInt16","getUint32","getUint16","s","c","String","fromCharCode","$","target","proto","_tempNormal","getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","halfArc","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","lenUv","RoundedBoxGeometry","width","height","depth","segments","min","geometry2","toNonIndexed","attributes","uv","box","divideScalar","subScalar","positions","array","normals","faceTris","halfSegmentSize","j","fromArray","z","floor","loadShader","shaderName","vertexShader","fragShader","err","controls","stats","rm","scene","suResolution","suBackground","suImage","suDepth","backColor","absorbColor","suRefractionFactor","suOpacity","originalMaterial","clone","refractionMaterialUniforms","environment","glassFrontVS","glassFrontFS","refractionMaterial","fragmentShader","uniforms","backgroundScene","container","renderer","camera","backDepthTextureSize","frontScene","backdepthTexture","backRenderTarget","offsetWidth","window","devicePixelRatio","offsetHeight","depthBuffer","depthTexture","type","background","refractionObjectList","textureCube","shader","lib","parameters","setDefaultBacksideMaterial","image","refractionFactor","opacityFactor","_backColor","metalness","reflectivity","roughness","forEach","refObj","setRenderTarget","render","initScene","_container","innerWidth","innerHeight","lookAt","antialias","alpha","setClearColor","setPixelRatio","setSize","appendChild","domElement","OrbitControls","style","top","left","zIndex","urls","mapping","light","floorTexture","wrapS","wrapT","floorMaterial","floorGeometry","rotation","glassMesh1","glassMesh2","glassMesh3","addRefractionMesh","ballMesh","addEventListener","onWindowResize","animate","aspect","updateProjectionMatrix","requestAnimationFrame","update","options","textureWidth","textureHeight","clipBias","ReflectorShader","reflectorPlane","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","q","textureMatrix","virtualCamera","renderTarget","onBeforeRender","setFromMatrixPosition","matrixWorld","extractRotation","subVectors","dot","reflect","negate","up","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","constant","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","state","buffers","setMask","autoClear","clear","viewport","dispose","prototype","isReflector","reflectionScene","flowDirection","flowSpeed","WaterShader","textureLoader","normalMap0","normalMap1","cycle","halfCycle","clock","reflector","updateTextureMatrix","updateFlow","delta","getDelta","config","matrixAutoUpdate","merge","fog"],"mappings":"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","file":"js/chunk-e59f6236.8167ebba.js","sourcesContent":["var map = {\n\t\"./GlassFrontShader/F.glsl\": \"f430\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"08fd\";","'use strict';\nvar global = require('../internals/global');\nvar toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\nvar toString = require('../internals/to-string');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nvar RangeError = global.RangeError;\n\n// `String.prototype.repeat` method implementation\n// https://tc39.es/ecma262/#sec-string.prototype.repeat\nmodule.exports = function repeat(count) {\n  var str = toString(requireObjectCoercible(this));\n  var result = '';\n  var n = toIntegerOrInfinity(count);\n  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;\n  return result;\n};\n","import {\n\tAdditiveBlending,\n\tBufferGeometry,\n\tColor,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tGroup,\n\tLoader,\n\tLoaderUtils,\n\tMatrix4,\n\tMesh,\n\tMeshPhongMaterial,\n\tTextureLoader\n} from 'three';\n\n/**\n * Autodesk 3DS three.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @class TDSLoader\n * @constructor\n */\n\nclass TDSLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.debug = false;\n\n\t\tthis.group = null;\n\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t}\n\n\t/**\n\t * Load 3ds file from url.\n\t *\n\t * @method load\n\t * @param {[type]} url URL for the file.\n\t * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n\t * @param {Function} onProgress onProgress callback.\n\t * @param {Function} onError onError callback.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( data, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parse arraybuffer data and load 3ds file.\n\t *\n\t * @method parse\n\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t * @param {String} path Path for external resources.\n\t * @return {Group} Group loaded from 3ds file.\n\t */\n\tparse( arraybuffer, path ) {\n\n\t\tthis.group = new Group();\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t\tthis.readFile( arraybuffer, path );\n\n\t\tfor ( let i = 0; i < this.meshes.length; i ++ ) {\n\n\t\t\tthis.group.add( this.meshes[ i ] );\n\n\t\t}\n\n\t\treturn this.group;\n\n\t}\n\n\t/**\n\t * Decode file content to read 3ds data.\n\t *\n\t * @method readFile\n\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t * @param {String} path Path for external resources.\n\t */\n\treadFile( arraybuffer, path ) {\n\n\t\tconst data = new DataView( arraybuffer );\n\t\tconst chunk = new Chunk( data, 0, this.debugMessage );\n\n\t\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\n\n\t\t\tlet next = chunk.readChunk();\n\n\t\t\twhile ( next ) {\n\n\t\t\t\tif ( next.id === M3D_VERSION ) {\n\n\t\t\t\t\tconst version = next.readDWord();\n\t\t\t\t\tthis.debugMessage( '3DS file version: ' + version );\n\n\t\t\t\t} else if ( next.id === MDATA ) {\n\n\t\t\t\t\tthis.readMeshData( next, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown main chunk: ' + next.hexId );\n\n\t\t\t\t}\n\n\t\t\t\tnext = chunk.readChunk();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @method readMeshData\n\t * @param {Chunk} chunk to read mesh from\n\t * @param {String} path Path for external resources.\n\t */\n\treadMeshData( chunk, path ) {\n\n\t\tlet next = chunk.readChunk();\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MESH_VERSION ) {\n\n\t\t\t\tconst version = + next.readDWord();\n\t\t\t\tthis.debugMessage( 'Mesh Version: ' + version );\n\n\t\t\t} else if ( next.id === MASTER_SCALE ) {\n\n\t\t\t\tconst scale = next.readFloat();\n\t\t\t\tthis.debugMessage( 'Master scale: ' + scale );\n\t\t\t\tthis.group.scale.set( scale, scale, scale );\n\n\t\t\t} else if ( next.id === NAMED_OBJECT ) {\n\n\t\t\t\tthis.debugMessage( 'Named Object' );\n\t\t\t\tthis.readNamedObject( next );\n\n\t\t\t} else if ( next.id === MAT_ENTRY ) {\n\n\t\t\t\tthis.debugMessage( 'Material' );\n\t\t\t\tthis.readMaterialEntry( next, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown MDATA chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read named object chunk.\n\t *\n\t * @method readNamedObject\n\t * @param {Chunk} chunk Chunk in use.\n\t */\n\treadNamedObject( chunk ) {\n\n\t\tconst name = chunk.readString();\n\n\t\tlet next = chunk.readChunk();\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === N_TRI_OBJECT ) {\n\n\t\t\t\tconst mesh = this.readMesh( next );\n\t\t\t\tmesh.name = name;\n\t\t\t\tthis.meshes.push( mesh );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( 'Unknown named object chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read material data chunk and add it to the material list.\n\t *\n\t * @method readMaterialEntry\n\t * @param {Chunk} chunk Chunk in use.\n\t * @param {String} path Path for external resources.\n\t */\n\treadMaterialEntry( chunk, path ) {\n\n\t\tlet next = chunk.readChunk();\n\t\tconst material = new MeshPhongMaterial();\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MAT_NAME ) {\n\n\t\t\t\tmaterial.name = next.readString();\n\t\t\t\tthis.debugMessage( '   Name: ' + material.name );\n\n\t\t\t} else if ( next.id === MAT_WIRE ) {\n\n\t\t\t\tthis.debugMessage( '   Wireframe' );\n\t\t\t\tmaterial.wireframe = true;\n\n\t\t\t} else if ( next.id === MAT_WIRE_SIZE ) {\n\n\t\t\t\tconst value = next.readByte();\n\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\tthis.debugMessage( '   Wireframe Thickness: ' + value );\n\n\t\t\t} else if ( next.id === MAT_TWO_SIDE ) {\n\n\t\t\t\tmaterial.side = DoubleSide;\n\t\t\t\tthis.debugMessage( '   DoubleSided' );\n\n\t\t\t} else if ( next.id === MAT_ADDITIVE ) {\n\n\t\t\t\tthis.debugMessage( '   Additive Blending' );\n\t\t\t\tmaterial.blending = AdditiveBlending;\n\n\t\t\t} else if ( next.id === MAT_DIFFUSE ) {\n\n\t\t\t\tthis.debugMessage( '   Diffuse Color' );\n\t\t\t\tmaterial.color = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_SPECULAR ) {\n\n\t\t\t\tthis.debugMessage( '   Specular Color' );\n\t\t\t\tmaterial.specular = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_AMBIENT ) {\n\n\t\t\t\tthis.debugMessage( '   Ambient color' );\n\t\t\t\tmaterial.color = this.readColor( next );\n\n\t\t\t} else if ( next.id === MAT_SHININESS ) {\n\n\t\t\t\tconst shininess = this.readPercentage( next );\n\t\t\t\tmaterial.shininess = shininess * 100;\n\t\t\t\tthis.debugMessage( '   Shininess : ' + shininess );\n\n\t\t\t} else if ( next.id === MAT_TRANSPARENCY ) {\n\n\t\t\t\tconst transparency = this.readPercentage( next );\n\t\t\t\tmaterial.opacity = 1 - transparency;\n\t\t\t\tthis.debugMessage( '  Transparency : ' + transparency );\n\t\t\t\tmaterial.transparent = material.opacity < 1 ? true : false;\n\n\t\t\t} else if ( next.id === MAT_TEXMAP ) {\n\n\t\t\t\tthis.debugMessage( '   ColorMap' );\n\t\t\t\tmaterial.map = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_BUMPMAP ) {\n\n\t\t\t\tthis.debugMessage( '   BumpMap' );\n\t\t\t\tmaterial.bumpMap = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_OPACMAP ) {\n\n\t\t\t\tthis.debugMessage( '   OpacityMap' );\n\t\t\t\tmaterial.alphaMap = this.readMap( next, path );\n\n\t\t\t} else if ( next.id === MAT_SPECMAP ) {\n\n\t\t\t\tthis.debugMessage( '   SpecularMap' );\n\t\t\t\tmaterial.specularMap = this.readMap( next, path );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown material chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk();\n\n\t\t}\n\n\t\tthis.materials[ material.name ] = material;\n\n\t}\n\n\t/**\n\t * Read mesh data chunk.\n\t *\n\t * @method readMesh\n\t * @param {Chunk} chunk Chunk in use.\n\t * @return {Mesh} The parsed mesh.\n\t */\n\treadMesh( chunk ) {\n\n\t\tlet next = chunk.readChunk( );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst material = new MeshPhongMaterial();\n\t\tconst mesh = new Mesh( geometry, material );\n\t\tmesh.name = 'mesh';\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === POINT_ARRAY ) {\n\n\t\t\t\tconst points = next.readWord( );\n\n\t\t\t\tthis.debugMessage( '   Vertex: ' + points );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst vertices = [];\n\n\t\t\t\tfor ( let i = 0; i < points; i ++ )\t\t{\n\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\t\t\t\t\tvertices.push( next.readFloat( ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t} else if ( next.id === FACE_ARRAY ) {\n\n\t\t\t\tthis.readFaceArray( next, mesh );\n\n\t\t\t} else if ( next.id === TEX_VERTS ) {\n\n\t\t\t\tconst texels = next.readWord( );\n\n\t\t\t\tthis.debugMessage( '   UV: ' + texels );\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tconst uvs = [];\n\n\t\t\t\tfor ( let i = 0; i < texels; i ++ ) {\n\n\t\t\t\t\tuvs.push( next.readFloat( ) );\n\t\t\t\t\tuvs.push( next.readFloat( ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t\t} else if ( next.id === MESH_MATRIX ) {\n\n\t\t\t\tthis.debugMessage( '   Tranformation Matrix (TODO)' );\n\n\t\t\t\tconst values = [];\n\t\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = next.readFloat( );\n\n\t\t\t\t}\n\n\t\t\t\tconst matrix = new Matrix4();\n\n\t\t\t\t//X Line\n\t\t\t\tmatrix.elements[ 0 ] = values[ 0 ];\n\t\t\t\tmatrix.elements[ 1 ] = values[ 6 ];\n\t\t\t\tmatrix.elements[ 2 ] = values[ 3 ];\n\t\t\t\tmatrix.elements[ 3 ] = values[ 9 ];\n\n\t\t\t\t//Y Line\n\t\t\t\tmatrix.elements[ 4 ] = values[ 2 ];\n\t\t\t\tmatrix.elements[ 5 ] = values[ 8 ];\n\t\t\t\tmatrix.elements[ 6 ] = values[ 5 ];\n\t\t\t\tmatrix.elements[ 7 ] = values[ 11 ];\n\n\t\t\t\t//Z Line\n\t\t\t\tmatrix.elements[ 8 ] = values[ 1 ];\n\t\t\t\tmatrix.elements[ 9 ] = values[ 7 ];\n\t\t\t\tmatrix.elements[ 10 ] = values[ 4 ];\n\t\t\t\tmatrix.elements[ 11 ] = values[ 10 ];\n\n\t\t\t\t//W Line\n\t\t\t\tmatrix.elements[ 12 ] = 0;\n\t\t\t\tmatrix.elements[ 13 ] = 0;\n\t\t\t\tmatrix.elements[ 14 ] = 0;\n\t\t\t\tmatrix.elements[ 15 ] = 1;\n\n\t\t\t\tmatrix.transpose();\n\n\t\t\t\tconst inverse = new Matrix4();\n\t\t\t\tinverse.copy( matrix ).invert();\n\t\t\t\tgeometry.applyMatrix4( inverse );\n\n\t\t\t\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '   Unknown mesh chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t\tgeometry.computeVertexNormals();\n\n\t\treturn mesh;\n\n\t}\n\n\t/**\n\t * Read face array data chunk.\n\t *\n\t * @method readFaceArray\n\t * @param {Chunk} chunk Chunk in use.\n\t * @param {Mesh} mesh Mesh to be filled with the data read.\n\t */\n\treadFaceArray( chunk, mesh ) {\n\n\t\tconst faces = chunk.readWord( );\n\n\t\tthis.debugMessage( '   Faces: ' + faces );\n\n\t\tconst index = [];\n\n\t\tfor ( let i = 0; i < faces; ++ i ) {\n\n\t\t\tindex.push( chunk.readWord( ), chunk.readWord( ), chunk.readWord( ) );\n\n\t\t\tchunk.readWord( ); // visibility\n\n\t\t}\n\n\t\tmesh.geometry.setIndex( index );\n\n\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\tlet materialIndex = 0;\n\t\tlet start = 0;\n\n\t\twhile ( ! chunk.endOfChunk ) {\n\n\t\t\tconst subchunk = chunk.readChunk( );\n\n\t\t\tif ( subchunk.id === MSH_MAT_GROUP ) {\n\n\t\t\t\tthis.debugMessage( '      Material Group' );\n\n\t\t\t\tconst group = this.readMaterialGroup( subchunk );\n\t\t\t\tconst count = group.index.length * 3; // assuming successive indices\n\n\t\t\t\tmesh.geometry.addGroup( start, count, materialIndex );\n\n\t\t\t\tstart += count;\n\t\t\t\tmaterialIndex ++;\n\n\t\t\t\tconst material = this.materials[ group.name ];\n\n\t\t\t\tif ( Array.isArray( mesh.material ) === false ) mesh.material = [];\n\n\t\t\t\tif ( material !== undefined )\t{\n\n\t\t\t\t\tmesh.material.push( material );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown face array chunk: ' + subchunk.hexId );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( mesh.material.length === 1 ) mesh.material = mesh.material[ 0 ]; // for backwards compatibility\n\n\t}\n\n\t/**\n\t * Read texture map data chunk.\n\t *\n\t * @method readMap\n\t * @param {Chunk} chunk Chunk in use.\n\t * @param {String} path Path for external resources.\n\t * @return {Texture} Texture read from this data chunk.\n\t */\n\treadMap( chunk, path ) {\n\n\t\tlet next = chunk.readChunk( );\n\t\tlet texture = {};\n\n\t\tconst loader = new TextureLoader( this.manager );\n\t\tloader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\twhile ( next ) {\n\n\t\t\tif ( next.id === MAT_MAPNAME ) {\n\n\t\t\t\tconst name = next.readString();\n\t\t\t\ttexture = loader.load( name );\n\n\t\t\t\tthis.debugMessage( '      File: ' + path + name );\n\n\t\t\t} else if ( next.id === MAT_MAP_UOFFSET ) {\n\n\t\t\t\ttexture.offset.x = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      OffsetX: ' + texture.offset.x );\n\n\t\t\t} else if ( next.id === MAT_MAP_VOFFSET ) {\n\n\t\t\t\ttexture.offset.y = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      OffsetY: ' + texture.offset.y );\n\n\t\t\t} else if ( next.id === MAT_MAP_USCALE ) {\n\n\t\t\t\ttexture.repeat.x = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      RepeatX: ' + texture.repeat.x );\n\n\t\t\t} else if ( next.id === MAT_MAP_VSCALE ) {\n\n\t\t\t\ttexture.repeat.y = next.readFloat( );\n\t\t\t\tthis.debugMessage( '      RepeatY: ' + texture.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage( '      Unknown map chunk: ' + next.hexId );\n\n\t\t\t}\n\n\t\t\tnext = chunk.readChunk( );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Read material group data chunk.\n\t *\n\t * @method readMaterialGroup\n\t * @param {Chunk} chunk Chunk in use.\n\t * @return {Object} Object with name and index of the object.\n\t */\n\treadMaterialGroup( chunk ) {\n\n\t\tconst name = chunk.readString();\n\t\tconst numFaces = chunk.readWord();\n\n\t\tthis.debugMessage( '         Name: ' + name );\n\t\tthis.debugMessage( '         Faces: ' + numFaces );\n\n\t\tconst index = [];\n\t\tfor ( let i = 0; i < numFaces; ++ i ) {\n\n\t\t\tindex.push( chunk.readWord( ) );\n\n\t\t}\n\n\t\treturn { name: name, index: index };\n\n\t}\n\n\t/**\n\t * Read a color value.\n\t *\n\t * @method readColor\n\t * @param {Chunk} chunk Chunk.\n\t * @return {Color} Color value read..\n\t */\n\treadColor( chunk ) {\n\n\t\tconst subChunk = chunk.readChunk( );\n\t\tconst color = new Color();\n\n\t\tif ( subChunk.id === COLOR_24 || subChunk.id === LIN_COLOR_24 ) {\n\n\t\t\tconst r = subChunk.readByte( );\n\t\t\tconst g = subChunk.readByte( );\n\t\t\tconst b = subChunk.readByte( );\n\n\t\t\tcolor.setRGB( r / 255, g / 255, b / 255 );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse if ( subChunk.id === COLOR_F || subChunk.id === LIN_COLOR_F ) {\n\n\t\t\tconst r = subChunk.readFloat( );\n\t\t\tconst g = subChunk.readFloat( );\n\t\t\tconst b = subChunk.readFloat( );\n\n\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t}\telse {\n\n\t\t\tthis.debugMessage( '      Unknown color chunk: ' + subChunk.hexId );\n\n\t\t}\n\n\t\treturn color;\n\n\t}\n\n\t/**\n\t * Read percentage value.\n\t *\n\t * @method readPercentage\n\t * @param {Chunk} chunk Chunk to read data from.\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadPercentage( chunk ) {\n\n\t\tconst subChunk = chunk.readChunk( );\n\n\t\tswitch ( subChunk.id ) {\n\n\t\t\tcase INT_PERCENTAGE:\n\t\t\t\treturn ( subChunk.readShort( ) / 100 );\n\t\t\t\tbreak;\n\n\t\t\tcase FLOAT_PERCENTAGE:\n\t\t\t\treturn subChunk.readFloat( );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthis.debugMessage( '      Unknown percentage chunk: ' + subChunk.hexId );\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Print debug message to the console.\n\t *\n\t * Is controlled by a flag to show or hide debug messages.\n\t *\n\t * @method debugMessage\n\t * @param {Object} message Debug message to print to the console.\n\t */\n\tdebugMessage( message ) {\n\n\t\tif ( this.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t}\n\n}\n\n\n/** Read data/sub-chunks from chunk */\nclass Chunk {\n\n\t/**\n\t * Create a new chunk\n\t *\n\t * @class Chunk\n\t * @param {DataView} data DataView to read from.\n\t * @param {Number} position in data.\n\t * @param {Function} debugMessage logging callback.\n\t */\n\tconstructor( data, position, debugMessage ) {\n\n\t\tthis.data = data;\n\t\t// the offset to the begin of this chunk\n\t\tthis.offset = position;\n\t\t// the current reading position\n\t\tthis.position = position;\n\t\tthis.debugMessage = debugMessage;\n\n\t\tif ( this.debugMessage instanceof Function ) {\n\n\t\t\tthis.debugMessage = function () {};\n\n\t\t}\n\n\t\tthis.id = this.readWord();\n\t\tthis.size = this.readDWord();\n\t\tthis.end = this.offset + this.size;\n\n\t\tif ( this.end > data.byteLength ) {\n\n\t\t\tthis.debugMessage( 'Bad chunk size for chunk at ' + position );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * read a sub cchunk.\n\t *\n\t * @method readChunk\n\t * @return {Chunk | null} next sub chunk\n\t */\n\treadChunk() {\n\n\t\tif ( this.endOfChunk ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst next = new Chunk( this.data, this.position, this.debugMessage );\n\t\t\tthis.position += next.size;\n\t\t\treturn next;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( 'Unable to read chunk at ' + this.position );\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * return the ID of this chunk as Hex\n\t *\n\t * @method idToString\n\t * @return {String} hex-string of id\n\t */\n\tget hexId() {\n\n\t\treturn this.id.toString( 16 );\n\n\t}\n\n\tget endOfChunk() {\n\n\t\treturn this.position >= this.end;\n\n\t}\n\n\t/**\n\t * Read byte value.\n\t *\n\t * @method readByte\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadByte() {\n\n\t\tconst v = this.data.getUint8( this.position, true );\n\t\tthis.position += 1;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit float value.\n\t *\n\t * @method readFloat\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadFloat() {\n\n\t\ttry {\n\n\t\t\tconst v = this.data.getFloat32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t}\tcatch ( e ) {\n\n\t\t\tthis.debugMessage( e + ' ' + this.position + ' ' + this.data.byteLength );\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Read 32 bit signed integer value.\n\t *\n\t * @method readInt\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadInt() {\n\n\t\tconst v = this.data.getInt32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 16 bit signed integer value.\n\t *\n\t * @method readShort\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadShort() {\n\n\t\tconst v = this.data.getInt16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 64 bit unsigned integer value.\n\t *\n\t * @method readDWord\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadDWord() {\n\n\t\tconst v = this.data.getUint32( this.position, true );\n\t\tthis.position += 4;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read 32 bit unsigned integer value.\n\t *\n\t * @method readWord\n\t * @return {Number} Data read from the dataview.\n\t */\n\treadWord() {\n\n\t\tconst v = this.data.getUint16( this.position, true );\n\t\tthis.position += 2;\n\t\treturn v;\n\n\t}\n\n\t/**\n\t * Read NULL terminated ASCII string value from chunk-pos.\n\t *\n\t * @method readString\n\t * @return {String} Data read from the dataview.\n\t */\n\treadString() {\n\n\t\tlet s = '';\n\t\tlet c = this.readByte();\n\t\twhile ( c ) {\n\n\t\t\ts += String.fromCharCode( c );\n\t\t\tc = this.readByte();\n\n\t\t}\n\n\t\treturn s;\n\n\t}\n\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4D4D;\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3DAA;\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xC23D;\nconst M3D_VERSION = 0x0002;\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010;\nconst COLOR_24 = 0x0011;\nconst LIN_COLOR_24 = 0x0012;\nconst LIN_COLOR_F = 0x0013;\nconst INT_PERCENTAGE = 0x0030;\nconst FLOAT_PERCENTAGE = 0x0031;\nconst MDATA = 0x3D3D;\nconst MESH_VERSION = 0x3D3E;\nconst MASTER_SCALE = 0x0100;\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xAFFF;\nconst MAT_NAME = 0xA000;\nconst MAT_AMBIENT = 0xA010;\nconst MAT_DIFFUSE = 0xA020;\nconst MAT_SPECULAR = 0xA030;\nconst MAT_SHININESS = 0xA040;\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xA050;\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xA081;\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xA083;\nconst MAT_WIRE = 0xA085;\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xA087;\nconst MAT_TEXMAP = 0xA200;\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xA210;\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xA230;\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xA204;\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xA300;\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xA354;\nconst MAT_MAP_VSCALE = 0xA356;\nconst MAT_MAP_UOFFSET = 0xA358;\nconst MAT_MAP_VOFFSET = 0xA35A;\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000;\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100;\nconst POINT_ARRAY = 0x4110;\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120;\nconst MSH_MAT_GROUP = 0x4130;\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140;\nconst MESH_MATRIX = 0x4160;\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\nexport { TDSLoader };\n","var $ = require('../internals/export');\nvar repeat = require('../internals/string-repeat');\n\n// `String.prototype.repeat` method\n// https://tc39.es/ecma262/#sec-string.prototype.repeat\n$({ target: 'String', proto: true }, {\n  repeat: repeat\n});\n","var map = {\n\t\"./GlassFrontShader/V.glsl\": \"c444\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"5303\";","import {\n\tBoxGeometry,\n\tVector3\n} from 'three';\n\nconst _tempNormal = new Vector3();\n\nfunction getUv( faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength ) {\n\n\tconst totArcLength = 2 * Math.PI * radius / 4;\n\n\t// length of the planes between the arcs on each axis\n\tconst centerLength = Math.max( sideLength - 2 * radius, 0 );\n\tconst halfArc = Math.PI / 4;\n\n\t// Get the vector projected onto the Y plane\n\t_tempNormal.copy( normal );\n\t_tempNormal[ projectionAxis ] = 0;\n\t_tempNormal.normalize();\n\n\t// total amount of UV space alloted to a single arc\n\tconst arcUvRatio = 0.5 * totArcLength / ( totArcLength + centerLength );\n\n\t// the distance along one arc the point is at\n\tconst arcAngleRatio = 1.0 - ( _tempNormal.angleTo( faceDirVector ) / halfArc );\n\n\tif ( Math.sign( _tempNormal[ uvAxis ] ) === 1 ) {\n\n\t\treturn arcAngleRatio * arcUvRatio;\n\n\t} else {\n\n\t\t// total amount of UV space alloted to the plane between the arcs\n\t\tconst lenUv = centerLength / ( totArcLength + centerLength );\n\t\treturn lenUv + arcUvRatio + arcUvRatio * ( 1.0 - arcAngleRatio );\n\n\t}\n\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, segments = 2, radius = 0.1 ) {\n\n\t\t// ensure segments is odd so we have a plane connecting the rounded corners\n\t\tsegments = segments * 2 + 1;\n\n\t\t// ensure radius isn't bigger than shortest side\n\t\tradius = Math.min( width / 2, height / 2, depth / 2, radius );\n\n\t\tsuper( 1, 1, 1, segments, segments, segments );\n\n\t\t// if we just have one segment we're the same as a regular box\n\t\tif ( segments === 1 ) return;\n\n\t\tconst geometry2 = this.toNonIndexed();\n\n\t\tthis.index = null;\n\t\tthis.attributes.position = geometry2.attributes.position;\n\t\tthis.attributes.normal = geometry2.attributes.normal;\n\t\tthis.attributes.uv = geometry2.attributes.uv;\n\n\t\t//\n\n\t\tconst position = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst box = new Vector3( width, height, depth ).divideScalar( 2 ).subScalar( radius );\n\n\t\tconst positions = this.attributes.position.array;\n\t\tconst normals = this.attributes.normal.array;\n\t\tconst uvs = this.attributes.uv.array;\n\n\t\tconst faceTris = positions.length / 6;\n\t\tconst faceDirVector = new Vector3();\n\t\tconst halfSegmentSize = 0.5 / segments;\n\n\t\tfor ( let i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tposition.fromArray( positions, i );\n\t\t\tnormal.copy( position );\n\t\t\tnormal.x -= Math.sign( normal.x ) * halfSegmentSize;\n\t\t\tnormal.y -= Math.sign( normal.y ) * halfSegmentSize;\n\t\t\tnormal.z -= Math.sign( normal.z ) * halfSegmentSize;\n\t\t\tnormal.normalize();\n\n\t\t\tpositions[ i + 0 ] = box.x * Math.sign( position.x ) + normal.x * radius;\n\t\t\tpositions[ i + 1 ] = box.y * Math.sign( position.y ) + normal.y * radius;\n\t\t\tpositions[ i + 2 ] = box.z * Math.sign( position.z ) + normal.z * radius;\n\n\t\t\tnormals[ i + 0 ] = normal.x;\n\t\t\tnormals[ i + 1 ] = normal.y;\n\t\t\tnormals[ i + 2 ] = normal.z;\n\n\t\t\tconst side = Math.floor( i / faceTris );\n\n\t\t\tswitch ( side ) {\n\n\t\t\t\tcase 0: // right\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1: // left\n\n\t\t\t\t\t// generate UVs along Z then Y\n\t\t\t\t\tfaceDirVector.set( - 1, 0, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'y', radius, depth );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'z', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // top\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // bottom\n\n\t\t\t\t\t// generate UVs along X then Z\n\t\t\t\t\tfaceDirVector.set( 0, - 1, 0 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'z', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'z', 'x', radius, depth );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4: // front\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, 1 );\n\t\t\t\t\tuvs[ j + 0 ] = 1.0 - getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 5: // back\n\n\t\t\t\t\t// generate UVs along X then Y\n\t\t\t\t\tfaceDirVector.set( 0, 0, - 1 );\n\t\t\t\t\tuvs[ j + 0 ] = getUv( faceDirVector, normal, 'x', 'y', radius, width );\n\t\t\t\t\tuvs[ j + 1 ] = 1.0 - getUv( faceDirVector, normal, 'y', 'x', radius, height );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nexport { RoundedBoxGeometry };\n","export function loadShader(shaderName: string): Array<string> {\r\n    try {\r\n        var vertexShader = require('./' + shaderName + '/V.glsl')\r\n        var fragShader = require('./' + shaderName + '/F.glsl')\r\n        return [vertexShader, fragShader]\r\n    }\r\n    catch(err) {\r\n        console.error('failed to fetch shader', err)\r\n        return ['', '']\r\n    }\r\n}","import * as THREE from 'three'\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\r\nimport { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry'\r\nimport { loadShader } from './ShaderLoader'\r\nimport { Stats } from 'three-stats'\r\nimport { ShaderMaterial } from 'three'\r\n\r\nexport class RefractionObject {\r\n    mesh: THREE.Mesh\r\n    originalMaterial: THREE.Material | THREE.Material[]\r\n    refractionMaterial: THREE.ShaderMaterial\r\n    backColor: THREE.Color\r\n    refractionMaterialUniforms: { [uniform: string]: THREE.IUniform }\r\n    // suResolution: THREE.Vector2\r\n    // suBackground: THREE.Texture\r\n    // suDepth: THREE.DepthTexture\r\n    constructor(scene: THREE.Scene, mesh: THREE.Mesh, suResolution: THREE.Vector2, suBackground: THREE.Texture, suImage: THREE.Texture | null, suDepth: THREE.DepthTexture,\r\n        backColor: THREE.Color, absorbColor: number, suRefractionFactor: number, suOpacity: number) {\r\n        this.mesh = mesh\r\n        this.mesh['refractionObject'] = this\r\n        // copy material\r\n        if (this.mesh.material instanceof Array) {\r\n            this.originalMaterial = new Array<THREE.Material>()\r\n            for (let i = 0; i < this.mesh.material.length; i++) {\r\n                this.originalMaterial.push(this.mesh.material[i].clone())\r\n            }\r\n        }\r\n        else {\r\n            this.originalMaterial = this.mesh.material.clone()\r\n        }\r\n        this.backColor = backColor\r\n        this.refractionMaterialUniforms = {\r\n            \"resolution\": { value: suResolution },\r\n            \"tBackground\":    { value: suBackground },\r\n            \"tBackDepth\": { value: suDepth },\r\n            \"tDisplayImage\": { value: suImage },\r\n            \"tSkybox\": { value: scene.environment },\r\n            \"refractionFactor\": { value: suRefractionFactor },\r\n            \"opacity\": { value: suOpacity },\r\n            \"absorbColor\": { value: new THREE.Color(absorbColor) },\r\n            \"objectCenter\": { value: mesh.position },\r\n        }\r\n        var [glassFrontVS, glassFrontFS] = loadShader('GlassFrontShader')\r\n        this.refractionMaterial = new ShaderMaterial({\r\n            vertexShader:   glassFrontVS,\r\n            fragmentShader: glassFrontFS,\r\n            uniforms: this.refractionMaterialUniforms,\r\n            // depthTest: false,\r\n            // stencilWrite: true,\r\n            // stencilRef: 999,\r\n            // stencilZPass: THREE.ReplaceStencilOp,  // write if the depth buffer test passes\r\n            side: THREE.FrontSide\r\n        })\r\n    }\r\n}\r\n\r\nexport class RefractionManager {\r\n    container: HTMLElement\r\n    backgroundScene: THREE.Scene\r\n    renderer: THREE.WebGLRenderer\r\n    camera: THREE.PerspectiveCamera\r\n\r\n    frontScene: THREE.Scene\r\n\r\n    backdepthTexture: THREE.DepthTexture\r\n    backRenderTarget: THREE.WebGLRenderTarget\r\n\r\n    refractionObjectList: Array<RefractionObject>\r\n\r\n    suResolution: THREE.Vector2\r\n\r\n    constructor(\r\n        backgroundScene: THREE.Scene, container: HTMLElement, renderer: THREE.WebGLRenderer, camera: THREE.PerspectiveCamera,\r\n        backDepthTextureSize: number = 512\r\n    ) {\r\n        this.container = container\r\n        this.backgroundScene = backgroundScene\r\n        this.renderer = renderer\r\n        this.camera = camera\r\n\r\n        this.frontScene = new THREE.Scene()\r\n        this.backdepthTexture = new THREE.DepthTexture(\r\n            backDepthTextureSize, backDepthTextureSize,\r\n            THREE.FloatType\r\n        )\r\n        this.backRenderTarget = new THREE.WebGLRenderTarget(\r\n            this.container.offsetWidth * window.devicePixelRatio,\r\n            this.container.offsetHeight * window.devicePixelRatio\r\n        )\r\n        this.backRenderTarget.depthBuffer = true;\r\n        this.backRenderTarget.depthTexture = this.backdepthTexture;\r\n        this.backRenderTarget.depthTexture.type = THREE.UnsignedIntType;\r\n        this.frontScene.background = this.backRenderTarget.texture\r\n        this.frontScene.environment = this.backgroundScene.environment\r\n        this.refractionObjectList = []\r\n        this.suResolution = new THREE.Vector2(\r\n            this.container.offsetWidth * window.devicePixelRatio,\r\n            this.container.offsetHeight * window.devicePixelRatio\r\n        )\r\n\r\n    }\r\n\r\n    genFresnelMaterial(textureCube: THREE.Texture | null) {\r\n        var shader = THREE.ShaderLib.lib[ \"fresnel\" ];\r\n        var uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n        uniforms[ \"tCube\" ].value = textureCube;\r\n\r\n        var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms };\r\n        var material = new THREE.ShaderMaterial( parameters );\r\n        return material\r\n    }\r\n\r\n    addRefractionMesh(mesh: THREE.Mesh, setDefaultBacksideMaterial: boolean = true,\r\n        image: THREE.Texture | null,\r\n        backColor: number = 0xffffff,\r\n        absorbColor: number = 0x000000, refractionFactor: number = 1.49, opacityFactor: number = 0.2) {\r\n        const _backColor = new THREE.Color(backColor)\r\n        if (setDefaultBacksideMaterial) {\r\n            mesh.material = new THREE.MeshPhysicalMaterial({\r\n                color: _backColor,\r\n                transparent: true,\r\n                opacity: 0.5,\r\n                metalness: 1,\r\n                reflectivity: 0,\r\n                roughness: 0,\r\n                side: THREE.BackSide\r\n                // colorWrite: false\r\n            })\r\n            // mesh.material = this.genFresnelMaterial(this.backgroundScene.environment)\r\n        }\r\n        this.refractionObjectList.push(new RefractionObject(\r\n            this.backgroundScene,\r\n            mesh,\r\n            this.suResolution,\r\n            this.backRenderTarget.texture,\r\n            image,\r\n            this.backRenderTarget.depthTexture,\r\n            _backColor,\r\n            absorbColor,\r\n            refractionFactor,\r\n            opacityFactor\r\n        ))\r\n        this.backgroundScene.add(mesh)\r\n    }\r\n\r\n    onWindowResize() {\r\n        this.suResolution.x = this.container.offsetWidth * window.devicePixelRatio\r\n        this.suResolution.y = this.container.offsetHeight * window.devicePixelRatio\r\n    }\r\n\r\n    render() {\r\n        this.refractionObjectList.forEach(refObj => {\r\n            refObj.mesh.material = refObj.refractionMaterial\r\n            this.frontScene.add(refObj.mesh)\r\n        })\r\n\r\n        this.renderer.setRenderTarget(null)\r\n        this.renderer.render(this.frontScene, this.camera)\r\n\r\n        this.refractionObjectList.forEach(refObj => {\r\n            refObj.mesh.material = refObj.originalMaterial\r\n            this.backgroundScene.add(refObj.mesh)\r\n        })\r\n    }\r\n}\r\n\r\nvar container: HTMLElement\r\nvar renderer: THREE.WebGLRenderer, camera: THREE.PerspectiveCamera, controls: OrbitControls\r\nvar stats: Stats\r\nvar scene: THREE.Scene\r\nvar rm: RefractionManager\r\n\r\nexport function initScene(_container: HTMLElement) {\r\n    container = _container\r\n    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 5000 )\r\n    camera.position.set(30, 20, 200)\r\n    camera.lookAt(0, 0, 0)\r\n\r\n    scene = new THREE.Scene()\r\n\r\n    renderer = new THREE.WebGLRenderer( {antialias: true, alpha: true} )\r\n    \r\n    renderer.setClearColor( 0xffffff )\r\n    renderer.setPixelRatio( window.devicePixelRatio )\r\n    renderer.setSize(window.innerWidth, window.innerHeight)\r\n    container.appendChild( renderer.domElement )\r\n    controls = new OrbitControls(camera, container)\r\n    container.style.position = 'absolute'\r\n    container.style.top = '0px'\r\n    container.style.left = '0px'\r\n    stats = new Stats()\r\n    stats.domElement.style.zIndex = '100'\r\n    container.appendChild( stats.domElement )\r\n\r\n    // set background\r\n    const r = './cube/'\r\n\r\n    const urls = [\r\n        r + 'px.jpg', r + 'nx.jpg',\r\n        r + 'py.jpg', r + 'ny.jpg',\r\n        r + 'pz.jpg', r + 'nz.jpg'\r\n    ]\r\n\r\n    const textureCube = new THREE.CubeTextureLoader().load( urls )\r\n    textureCube.mapping = THREE.CubeRefractionMapping\r\n\r\n    scene.background = textureCube\r\n    scene.environment = textureCube\r\n    \r\n    // set light\r\n    var light = new THREE.DirectionalLight()\r\n    light.position.x = 300\r\n    light.position.y = 200\r\n    light.position.z = 100\r\n    scene.add(light)\r\n\r\n    // set floor\r\n    var floorTexture = new THREE.TextureLoader().load( './checkerboard.jpg' )\r\n\tfloorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping\r\n\tfloorTexture.repeat.set( 10, 10 )\r\n    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } )\r\n\tvar floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1)\r\n\tvar floor = new THREE.Mesh(floorGeometry, floorMaterial)\r\n\tfloor.position.y -= 20.1\r\n\tfloor.rotation.x = Math.PI / 2\r\n    // scene.add(floor)\r\n\r\n    rm = new RefractionManager(scene, container, renderer, camera)\r\n\r\n    var glassMesh1 = new THREE.Mesh(\r\n        new RoundedBoxGeometry(40, 40, 40, 5, 5),\r\n        new THREE.MeshPhongMaterial({})\r\n    )\r\n    glassMesh1.position.x -= 40\r\n    var glassMesh2 = new THREE.Mesh(\r\n        new THREE.SphereGeometry( 20 ),\r\n        new THREE.MeshPhongMaterial({})\r\n    )\r\n    var glassMesh3 = new THREE.Mesh(\r\n        new THREE.CylinderGeometry( 20, 20, 80, 36 ),\r\n        new THREE.MeshPhongMaterial({})\r\n    )\r\n    glassMesh3.position.x += 40\r\n    glassMesh3.position.y += 20\r\n\r\n    rm.addRefractionMesh(glassMesh1, true, null, 0x000000, 0x000000)\r\n    rm.addRefractionMesh(glassMesh2, true, null, 0x006000, 0x006000)\r\n    rm.addRefractionMesh(glassMesh3, true, null, 0x000633, 0x000633)\r\n\r\n    // add a few spheres\r\n    var ballMesh = new THREE.Mesh(\r\n        new THREE.SphereGeometry( 20 ),\r\n        new THREE.MeshPhongMaterial({\r\n            color: 0xff0000\r\n        })\r\n    )\r\n    ballMesh.position.copy(glassMesh1.position)\r\n    ballMesh.position.z -= 50\r\n    scene.add(ballMesh)\r\n\r\n    window.addEventListener( 'resize', onWindowResize )\r\n    animate()\r\n\r\n}\r\n\r\nfunction onWindowResize() {\r\n\r\n    camera.aspect = window.innerWidth / window.innerHeight\r\n    camera.updateProjectionMatrix()\r\n    rm.onWindowResize()\r\n    renderer.setSize( window.innerWidth, window.innerHeight )\r\n\r\n}\r\n\r\nfunction animate() {\r\n    requestAnimationFrame( animate )\r\n    render()\r\n    controls.update()\r\n    stats.update()\r\n}\r\n\r\nfunction render()\r\n{\r\n    rm.render()\r\n}","module.exports = \"varying vec2 vUv;\\r\\nvarying vec3 vNormal;\\r\\nvarying vec3 vCameraPosition;\\r\\nvarying vec4 vWorldPosition;\\r\\nvarying mat4 vProjectionMatrix;\\r\\n// varying vec3 vRefract;\\r\\n// varying vec2 vRefractOffset;\\r\\nvarying vec4 vImageUVCenter;\\r\\n\\r\\nuniform vec3 objectCenter;\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n    vWorldPosition = modelMatrix * vec4( position, 1.0 );\\r\\n    vec4 mvPosition = viewMatrix * vWorldPosition;\\r\\n    gl_Position = projectionMatrix * mvPosition;\\r\\n    vUv = uv;\\r\\n\\r\\n    vNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\\r\\n    vCameraPosition = cameraPosition;\\r\\n\\r\\n    vProjectionMatrix = projectionMatrix * modelViewMatrix;\\r\\n    vImageUVCenter = vProjectionMatrix * vec4( objectCenter, 1.0 );\\r\\n}\\r\\n\"","module.exports = \"uniform vec2 resolution;\\r\\nuniform sampler2D tBackground;\\r\\nuniform sampler2D tBackDepth;\\r\\nuniform sampler2D tDisplayImage;\\r\\n\\r\\nuniform samplerCube tSkybox;\\r\\nuniform vec3 absorbColor;\\r\\nuniform float refractionFactor;\\r\\nuniform float opacity;\\r\\n\\r\\nvarying vec2 vUv;\\r\\nvarying vec3 vNormal;\\r\\nvarying vec3 vCameraPosition;\\r\\nvarying vec4 vWorldPosition;\\r\\nvarying mat4 vProjectionMatrix;\\r\\nvarying vec4 vImageUVCenter;\\r\\n\\r\\nfloat near = 0.1;\\r\\nfloat far  = 5000.0;\\r\\n\\r\\nfloat LinearizeDepth(float depth) \\r\\n{\\r\\n    float z = depth * 2.0 - 1.0; // back to NDC \\r\\n    return (2.0 * near * far) / (far + near - z * (far - near));\\t\\r\\n}\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n    // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\r\\n    // return;\\r\\n    float backDepth = float(texture2D( tBackDepth, vec2( gl_FragCoord.x / resolution.x, gl_FragCoord.y / resolution.y ) ).x);\\r\\n    float frontDepth = gl_FragCoord.z;\\r\\n\\r\\n    if (frontDepth > backDepth) {\\r\\n        discard;\\r\\n    }\\r\\n\\r\\n    float backDepthlinear = LinearizeDepth(backDepth);\\r\\n    float frontDepthlinear = LinearizeDepth(frontDepth);\\r\\n    \\r\\n    float backToFrontDepth = backDepthlinear - frontDepthlinear;\\r\\n    backToFrontDepth *= 0.5;\\r\\n    \\r\\n    vec3 vCameraRay = vWorldPosition.xyz / vWorldPosition.w - vCameraPosition;\\r\\n    vCameraRay = normalize(vCameraRay);\\r\\n    vec3 vRefract = refract( vCameraRay, vNormal, 1.0 / refractionFactor );\\r\\n    vec4 vOriginalPos = vWorldPosition + vec4(vCameraRay, 0.0);\\r\\n    vec4 vRefractedPos = vWorldPosition + vec4(vRefract, 0.0);\\r\\n    // vRefractedPos = vOriginalPos; //vWorldPosition + vec4(vRefract, 0.0);\\r\\n    vec4 vOriginalProjectedPos = vProjectionMatrix * vOriginalPos;\\r\\n    vec4 vRefractedProjectedPos = vProjectionMatrix * vRefractedPos;\\r\\n    vec2 offset = normalize(vRefractedProjectedPos - vOriginalProjectedPos).xy;\\r\\n    offset = normalize(offset);\\r\\n\\r\\n    // reflect\\r\\n    vec3 vReflect = reflect( vCameraRay, vNormal );\\r\\n    vec3 refCol = vec3(textureCube(tSkybox, vReflect));\\r\\n\\r\\n    // snell's law\\r\\n    float cosTheta1 = dot(vCameraRay, vNormal);\\r\\n    float sinTheta1 = 1.0 - cosTheta1 * cosTheta1;\\r\\n    float sinTheta2 = sinTheta1 / refractionFactor;\\r\\n    float theta2 = asin(sinTheta2);\\r\\n    offset *= sinTheta2;\\r\\n    offset *= 100.0;\\r\\n\\r\\n    offset /= backDepth;\\r\\n\\r\\n    float samplePointX_r = (gl_FragCoord.x + backToFrontDepth * offset.x * 0.9) / resolution.x;\\r\\n    float samplePointY_r = (gl_FragCoord.y + backToFrontDepth * offset.y * 0.9) / resolution.y;\\r\\n\\r\\n    float samplePointX_g = (gl_FragCoord.x + backToFrontDepth * offset.x * 0.95) / resolution.x;\\r\\n    float samplePointY_g = (gl_FragCoord.y + backToFrontDepth * offset.y * 0.95) / resolution.y;\\r\\n\\r\\n    float samplePointX_b = (gl_FragCoord.x + backToFrontDepth * offset.x) / resolution.x;\\r\\n    float samplePointY_b = (gl_FragCoord.y + backToFrontDepth * offset.y) / resolution.y;\\r\\n    \\r\\n    float backColor_r = texture2D( tBackground, vec2( samplePointX_r, samplePointY_r ) * 1.0 ).x;\\r\\n    float backColor_g = texture2D( tBackground, vec2( samplePointX_g, samplePointY_g ) * 1.0 ).y;\\r\\n    float backColor_b = texture2D( tBackground, vec2( samplePointX_b, samplePointY_b ) * 1.0 ).z;\\r\\n\\r\\n    vec3 backColor = vec3(backColor_r, backColor_g, backColor_b);\\r\\n    vec3 absorbColor = absorbColor * sqrt(backToFrontDepth) * opacity;\\r\\n    float sqrtDepth = sqrt(backToFrontDepth) * opacity;\\r\\n    float absorbFactor = sqrtDepth / (1.0 + sqrtDepth);\\r\\n    vec3 refractCol = mix(backColor, absorbColor, absorbFactor);\\r\\n\\r\\n    // backColor = texture2D( tBackground, vec2( (gl_FragCoord.x + backToFrontDepth * offset.x) / resolution.x, (gl_FragCoord.y + backToFrontDepth * offset.y) / resolution.y ) * 1.0 ).xyz;\\r\\n\\r\\n    // gl_FragColor = vec4(refCol, 1.0);\\r\\n    float reflectionCoeff = pow(sinTheta1, 4.0);\\r\\n    // reflectionCoeff = 1.0;\\r\\n\\r\\n    // vec4 image = vec4(vec3(texture2D( tDisplayImage, vec2( (gl_FragCoord.x + vImageUVCenter.x) / resolution.x, (gl_FragCoord.y + vImageUVCenter.y) / resolution.y ) )), 1.0);\\r\\n    // vec4 image = vec4((gl_FragCoord.x + vImageUVCenter.x) / resolution.x, (gl_FragCoord.y + vImageUVCenter.y) / resolution.y, 1.0, 1.0);\\r\\n    // vec4 image = vec4(1.0, 0.0, 0.0, 1.0);\\r\\n\\r\\n    // gl_FragColor = vec4(mix(refractCol, refCol, reflectionCoeff), 1.0);\\r\\n    gl_FragColor = vec4(mix(refractCol, refCol, reflectionCoeff), 1.0);\\r\\n    // gl_FragColor = image;\\r\\n    // if (gl_FragCoord.x < 600.0) {\\r\\n    //     gl_FragColor = vec4(mix(refractCol, refCol, reflectionCoeff), 1.0);\\r\\n    // }\\r\\n    // gl_FragColor = vec4(backColor, 1.0);\\r\\n    // gl_FragColor = vec4(vec3(backDepthlinear * 0.01), 1.0);\\r\\n}\"","import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget\n} from 'three';\n\nclass Reflector extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.type = 'Reflector';\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = new PerspectiveCamera();\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\n\t\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.prototype.isReflector = true;\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Reflector };\n","import {\r\n\tClock,\r\n\tColor,\r\n\tMatrix4,\r\n\tMesh,\r\n\tRepeatWrapping,\r\n\tShaderMaterial,\r\n\tTextureLoader,\r\n\tUniformsLib,\r\n\tUniformsUtils,\r\n\tVector2,\r\n\tVector4,\r\n    BufferGeometry,\r\n    Camera,\r\n    Material,\r\n    Group,\r\n    Scene\r\n} from 'three';\r\nimport { Reflector } from 'three/examples/jsm/objects/Reflector'\r\nimport { Refractor } from 'three/examples/jsm/objects/Refractor'\r\nimport { Water2Options } from 'three/examples/jsm/objects/Water2'\r\n/**\r\n * References:\r\n *\thttps://github.com/mrdoob/three.js/blob/dev/examples/jsm/objects/Water2.js\r\n *\r\n */\r\n\r\nclass SQWater extends Mesh {\r\n\r\n    material: ShaderMaterial\r\n\r\n\tconstructor( geometry: BufferGeometry, reflectionScene: Scene, options: Water2Options = {} ) {\r\n\r\n\t\tsuper( geometry );\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0xFFFFFF );\r\n\t\tconst textureWidth = options.textureWidth || 512;\r\n\t\tconst textureHeight = options.textureHeight || 512;\r\n\t\tconst clipBias = options.clipBias || 0;\r\n\t\tconst flowDirection = options.flowDirection || new Vector2( 1, 0 );\r\n\t\tconst flowSpeed = options.flowSpeed || 0.01;\r\n\t\tconst reflectivity = options.reflectivity || 0.5;\r\n\t\tconst scale = options.scale || 1;\r\n\t\tconst shader = WaterShader;\r\n\r\n\t\tconst textureLoader = new TextureLoader();\r\n\r\n\t\tconst normalMap0 = options.normalMap0 || textureLoader.load( './water/Water_1_M_Normal.jpg' );\r\n\t\tconst normalMap1 = options.normalMap1 || textureLoader.load( './water/Water_2_M_Normal.jpg' );\r\n\r\n\t\tconst cycle = 0.15; // a cycle of a flow map phase\r\n\t\tconst halfCycle = cycle * 0.5;\r\n\t\tconst textureMatrix = new Matrix4();\r\n\t\tconst clock = new Clock();\r\n        this.material = new ShaderMaterial()\r\n\t\t// internal components\r\n\r\n\t\tconst reflector = new Reflector( geometry, {\r\n\t\t\ttextureWidth: textureWidth,\r\n\t\t\ttextureHeight: textureHeight,\r\n\t\t\tclipBias: clipBias\r\n\t\t} );\r\n\r\n\t\treflector.matrixAutoUpdate = false\r\n\r\n\t\t// material\r\n\r\n\t\tthis.material = new ShaderMaterial( {\r\n\t\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\t\tUniformsLib[ 'fog' ],\r\n\t\t\t\tshader.uniforms\r\n\t\t\t] ),\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\ttransparent: true,\r\n\t\t\tfog: true\r\n\t\t} );\r\n\r\n        this.material.uniforms[ 'flowDirection' ].value = flowDirection\r\n\r\n\t\t// maps\r\n\r\n\t\tnormalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\r\n\t\tnormalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\r\n\r\n\t\tthis.material.uniforms[ 'tReflectionMap' ].value = reflector.getRenderTarget().texture;\r\n\t\tthis.material.uniforms[ 'tNormalMap0' ].value = normalMap0;\r\n\t\tthis.material.uniforms[ 'tNormalMap1' ].value = normalMap1;\r\n\r\n\t\t// water\r\n\r\n\t\tthis.material.uniforms[ 'reflectivity' ].value = reflectivity;\r\n\t\tthis.material.uniforms[ 'textureMatrix' ].value = textureMatrix;\r\n\r\n\t\t// inital values\r\n\r\n\t\tthis.material.uniforms[ 'config' ].value.x = 0; // flowMapOffset0\r\n\t\tthis.material.uniforms[ 'config' ].value.y = halfCycle; // flowMapOffset1\r\n\t\tthis.material.uniforms[ 'config' ].value.z = halfCycle; // halfCycle\r\n\t\tthis.material.uniforms[ 'config' ].value.w = scale; // scale\r\n\r\n\t\t// functions\r\n\r\n\t\tfunction updateTextureMatrix( camera: Camera ) {\r\n\r\n\t\t\ttextureMatrix.set(\r\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t);\r\n\r\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\r\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\r\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\tfunction updateFlow() {\r\n\r\n\t\t\tconst delta = clock.getDelta();\r\n\t\t\tconst config = scope.material.uniforms[ 'config' ];\r\n\r\n\t\t\tconfig.value.x += flowSpeed * delta; // flowMapOffset0\r\n\t\t\tconfig.value.y = config.value.x + halfCycle; // flowMapOffset1\r\n\r\n\t\t\t// Important: The distance between offsets should be always the value of \"halfCycle\".\r\n\t\t\t// Moreover, both offsets should be in the range of [ 0, cycle ].\r\n\t\t\t// This approach ensures a smooth water flow and avoids \"reset\" effects.\r\n\r\n\t\t\tif ( config.value.x >= cycle ) {\r\n\r\n\t\t\t\tconfig.value.x = 0;\r\n\t\t\t\tconfig.value.y = halfCycle;\r\n\r\n\t\t\t} else if ( config.value.y >= cycle ) {\r\n\r\n\t\t\t\tconfig.value.y = config.value.y - cycle;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tthis.onBeforeRender = function ( renderer, scene, camera: Camera, geometry: BufferGeometry, material: Material, group: Group ) {\r\n\r\n\t\t\tupdateTextureMatrix( camera );\r\n\t\t\tupdateFlow();\r\n\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t\treflector.matrixWorld.copy( scope.matrixWorld );\r\n\r\n\t\t\treflector.onBeforeRender( renderer, reflectionScene, camera, geometry, material, group );\r\n\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst WaterShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'reflectivity': {\r\n\t\t\ttype: 'f',\r\n\t\t\tvalue: 0\r\n\t\t},\r\n\r\n\t\t'tReflectionMap': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tRefractionMap': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tNormalMap0': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tNormalMap1': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\ttype: 'm4',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'config': {\r\n\t\t\ttype: 'v4',\r\n\t\t\tvalue: new Vector4()\r\n\t\t},\r\n\r\n\t\t'flowDirection': {\r\n            type: 'v2',\r\n            value: new Vector2()\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\tuniform mat4 textureMatrix;\r\n\r\n\t\tvarying vec4 vCoord;\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 vToEye;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\r\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\r\n\r\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\r\n\t\tuniform sampler2D tReflectionMap;\r\n\t\tuniform sampler2D tRefractionMap;\r\n\t\tuniform sampler2D tNormalMap0;\r\n\t\tuniform sampler2D tNormalMap1;\r\n\r\n\t\tuniform vec2 flowDirection;\r\n\r\n\t\tuniform float reflectivity;\r\n\t\tuniform vec4 config;\r\n\r\n\t\tvarying vec4 vCoord;\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 vToEye;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\r\n\t\t\tfloat flowMapOffset0 = config.x;\r\n\t\t\tfloat flowMapOffset1 = config.y;\r\n\t\t\tfloat halfCycle = config.z;\r\n\t\t\tfloat scale = config.w;\r\n\r\n\t\t\tvec3 toEye = normalize( vToEye );\r\n\r\n\t\t\t// determine flow direction\r\n\t\t\tvec2 flow;\r\n\t\t\tflow = flowDirection;\r\n\t\t\tflow.x *= - 1.0;\r\n\r\n\t\t\t// sample normal maps (distort uvs with flowdata)\r\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\r\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\r\n\r\n\t\t\t// linear interpolate to get the final normal color\r\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\r\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\r\n\r\n\t\t\t// calculate normal vector\r\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\r\n\r\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\r\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\r\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\r\n            reflectance = pow(reflectance + 0.3, 4.0);\r\n            // reflectance = floor(reflectance *  2.0) / 4.0;\r\n            vec4 refractColor = vec4(1.0);\r\n\r\n\t\t\t// calculate final uv coords\r\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\r\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\r\n\r\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\r\n            reflectColor *= vec4(1.0, 1.0, 0.8, 1.0);\r\n\r\n\t\t\tgl_FragColor = mix(refractColor, reflectColor, reflectance);\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { SQWater };"],"sourceRoot":""}