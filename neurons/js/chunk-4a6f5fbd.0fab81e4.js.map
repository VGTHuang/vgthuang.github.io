{"version":3,"sources":["webpack:///./src/components/MyCanvas.vue?a478","webpack:///src/components/MyCanvas.vue","webpack:///./src/components/MyCanvas.vue?3597","webpack:///./src/components/MyCanvas.vue","webpack:///./src/components/MyCanvas.vue?3f9c"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticClass","directives","name","rawName","value","expression","attrs","domProps","_s","mouseHint","on","$event","mouseHintShow","_v","$t","ref","onCanvasMouseDown","onCanvasClickedOrTouched","onCanvasDblClick","onCanvasTouchStart","onCanvasTouchEnd","rightClickSelectedNeuron","model","callback","$$v","rightClickMaterialDialogOpen","stopPropagation","togglePanel","panelsOpen","class","$store","state","isMobile","style","camera","controls","neuronList","bgColor","lights","loadObj","saveConfigJson","loadCanvas","saveScreenshot","bgColorChanged","controlsTypeChanged","_e","staticRenderFns","component","VBtn","VCard","VFlex","VIcon"],"mappings":"uHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,YAAY,oBAAoB,CAACF,EAAG,kBAAkBA,EAAG,SAAS,CAACG,WAAW,CAAC,CAACC,KAAK,OAAOC,QAAQ,SAASC,MAAOV,EAAiB,cAAEW,WAAW,kBAAkBL,YAAY,4CAA4CM,MAAM,CAAC,MAAQ,cAAc,CAACR,EAAG,SAAS,CAACE,YAAY,OAAOO,SAAS,CAAC,UAAYb,EAAIc,GAAGd,EAAIe,cAAcX,EAAG,QAAQ,CAACQ,MAAM,CAAC,KAAO,IAAII,GAAG,CAAC,MAAQ,SAASC,GAAQjB,EAAIkB,eAAc,KAAS,CAAClB,EAAImB,GAAGnB,EAAIc,GAAGd,EAAIoB,GAAG,kBAAkB,GAAGhB,EAAG,MAAM,CAACiB,IAAI,aAAaf,YAAY,cAAc,CAACF,EAAG,SAAS,CAACiB,IAAI,cAAcT,MAAM,CAAC,GAAK,eAAeI,GAAG,CAAC,UAAYhB,EAAIsB,kBAAkB,QAAUtB,EAAIuB,yBAAyB,SAAWvB,EAAIwB,iBAAiB,WAAaxB,EAAIyB,mBAAmB,SAAWzB,EAAI0B,sBAAsBtB,EAAG,kBAAkB,CAACQ,MAAM,CAAC,OAASZ,EAAI2B,0BAA0BX,GAAG,CAAC,gBAAkBhB,EAAID,QAAQ6B,MAAM,CAAClB,MAAOV,EAAgC,6BAAE6B,SAAS,SAAUC,GAAM9B,EAAI+B,6BAA6BD,GAAKnB,WAAW,kCAAkCP,EAAG,QAAQ,CAACE,YAAY,oBAAoBM,MAAM,CAAC,MAAQ,MAAM,IAAM,IAAII,GAAG,CAAC,MAAQ,SAASC,GAAiC,OAAzBA,EAAOe,kBAAyBhC,EAAIiC,YAAYhB,MAAW,CAACb,EAAG,SAAS,CAACQ,MAAM,CAAC,MAAQ,UAAU,CAACZ,EAAImB,GAAGnB,EAAIc,GAAGd,EAAIkC,WAAa,YAAc,gBAAgB,GAAG9B,EAAG,MAAM,CAACE,YAAY,+BAA+B6B,MAAM,CAAC,0BAA4BnC,EAAIoC,OAAOC,MAAMC,UAAUC,MAAM,CACx9C,aAAevC,EAAIkC,WAAa,oBAAsB,MACtD,CAAElC,EAAa,UAAEI,EAAG,MAAM,CAACE,YAAY,kBAAkB,CAACF,EAAG,eAAe,CAACiB,IAAI,cAAcT,MAAM,CAAC,OAAS,SAAS,OAASZ,EAAIwC,OAAO,SAAWxC,EAAIyC,SAAS,WAAazC,EAAI0C,YAAY1B,GAAG,CAAC,WAAahB,EAAID,UAAUK,EAAG,cAAc,CAACiB,IAAI,aAAaT,MAAM,CAAC,UAAW,EAAK,QAAUZ,EAAI2C,QAAQ,OAAS3C,EAAI4C,OAAO,WAAa5C,EAAI0C,YAAY1B,GAAG,CAAC,OAAShB,EAAI6C,QAAQ,eAAiB7C,EAAI8C,eAAe,WAAa9C,EAAI+C,WAAW,eAAiB/C,EAAIgD,eAAe,eAAiBhD,EAAIiD,eAAe,WAAajD,EAAID,OAAO,oBAAsB,SAASkB,GAAQ,OAAOjB,EAAIkD,oBAAoBjC,QAAa,GAAGjB,EAAImD,QAAQ,IAChoBC,EAAkB,G,2hBCmGtB,GACE,KAAF,WACE,WAAF,CAEI,cAAJ,OAGI,eAAJ,OACI,WAAJ,OACI,YAAJ,QAEE,KAAF,WACI,MAAJ,CACM,eAAN,EAEM,IAAN,GACM,KAAN,GACM,IAAN,IAEM,YAAN,IACM,aAAN,IAEM,YAAN,EACM,eAAN,EACM,YAAN,EACM,WAAN,EACM,cAAN,EACM,cAAN,EAEM,WAAN,EAGM,QAAN,UACM,WAAN,UAEM,YAAN,EAEM,iBAAN,EACM,WAAN,EACM,YAAN,EAGM,OAAN,CACA,CACQ,WAAR,EACQ,SAAR,EACQ,cAAR,GAEA,CACQ,WAAR,EACQ,SAAR,GACQ,UAAR,kBACQ,cAAR,GAEA,CACQ,WAAR,EACQ,SAAR,GACQ,UAAR,mBACQ,cAAR,IAMM,eAAN,EACM,WAAN,GACM,UAAN,GACM,iBAAN,gCACM,YAAN,EAGM,gBAAN,EACM,4BAAN,GACM,0BAAN,GAGM,eAAN,EAEM,eAAN,EAEM,eAAN,gBACQ,KAAR,SAEM,YAAN,oBAEM,YAAN,GACM,8BAAN,EACM,8BAAN,EACM,eAAN,EAGM,QAAN,GAGM,oBAAN,EACM,oBAAN,EAGM,SAAN,GAEM,UAAN,2BACA,+BAEA,gCACM,eAAN,IAGE,QA3GF,WA4GI,KAAJ,iCACI,KAAJ,mCACI,OAAJ,qBACI,OAAJ,2BACM,IAAN,kBAMM,OAJN,IACQ,EAAR,0CAGA,8BAEI,KAAJ,WAEE,QAAF,CACI,QADJ,WACM,IAAN,OAEA,uBACM,EAAN,2CACQ,EAAR,OACQ,EAAR,sCACA,oBACQ,EAAR,2BACU,EAAV,aACU,EAAV,0BAII,kBAdJ,SAcA,OACM,IAAN,OACM,OAAN,2BAEQ,EAAR,sBACU,SAAV,cACA,EACc,EAAd,GAGc,EAAd,IAGU,SAAV,YACY,EAAZ,oDACY,EAAZ,gDACY,EAAZ,0DAIA,kBAEQ,OAAR,oBAEA,kBACA,qBACQ,OAAR,MAGI,WA3CJ,SA2CA,GAAM,IAAN,OAEM,KAAN,cAGM,KAAN,yDACM,KAAN,2DAEM,KAAN,oCACM,KAAN,sCAEA,uBAEQ,KAAR,iBACQ,KAAR,qBACQ,KAAR,oCAEM,KAAN,yBACM,KAAN,6BAEM,KAAN,8BAEQ,GAAR,SACU,IAAV,sBACU,EAAV,0BACU,EAAV,yBAGU,EAAV,wBAEQ,EAAR,mDACQ,EAAR,uCAGA,uBACQ,KAAR,qBACU,OAAV,YACU,WAAV,EACU,uBAAV,KAGM,KAAN,qDACM,KAAN,+BAKA,wBACQ,KAAR,yCAGQ,KAAR,iCAIA,0CACQ,KAAR,wCACA,QAEQ,KAAR,gBAEM,KAAN,qBAEM,KAAN,eAGM,KAAN,eACM,KAAN,iBACA,QACQ,EAAR,0BACU,EAAV,oBAMM,KAAN,cACM,KAAN,iBACM,KAAN,kBACM,KAAN,6DACM,KAAN,oBACM,KAAN,kBACM,KAAN,mBACM,KAAN,cAEM,IAAN,KACM,GAAN,SACQ,IAAR,kBACA,2BACY,GAAZ,GAEU,KAAV,kBAGA,GACQ,KAAR,sCAGM,KAAN,qCAIM,KAAN,4BAGM,IAAN,KACA,KAGA,IAEM,EAAN,gCACQ,EAAR,iBACQ,IAAR,wBACA,YACU,GAAV,MAIA,KAEQ,KAAR,gDACQ,KAAR,6BAIQ,KAAR,4BAGM,IAAN,IAEM,EAAN,gCACQ,EAAR,iBAEQ,IAAR,wBACQ,GAAR,WAEU,IAAV,oCACU,QAAV,OACU,IAAV,+CACY,IAAZ,uBACY,EAAZ,qBACc,IAAd,wBACc,GAAd,WACgB,IAAhB,UACA,4BACgB,EAAhB,KACgB,EAAhB,oCAIU,EAAV,QACU,GAAV,MAEA,YACU,EAAV,iCAIM,QAAN,wBAEQ,QAAR,mBACA,mBAEQ,EAAR,uBACU,QAAV,gCACU,QAAV,SAEA,oBAEQ,EAAR,4BACQ,EAAR,kBACQ,EAAR,0DACQ,EAAR,0BACA,8CACQ,EAAR,oBAII,WA9NJ,SA8NA,KAAM,IAAN,OACA,KAKA,KANA,WAOA,GACQ,EAAR,+BACU,EAAV,SAFM,IAAN,kBAAQ,EAAR,GAMM,IAAN,IAGM,OAAN,6BACQ,IAAR,OACA,mBACA,EACA,EACA,oCACA,kBACU,EAAV,kCAEQ,EAAR,QACQ,GAAR,KAIM,EAAN,gCAEQ,IAAR,wBAEQ,GAAR,WAEU,IAAV,cACA,kCACA,EACA,oCACA,kBACY,EAAZ,kCAEU,EAAV,QACU,GAAV,MAIM,QAAN,wBAEQ,QAAR,uBACA,mBAEQ,EAAR,uBACU,QAAV,+BACU,QAAV,SAEA,oBAKQ,GAHA,EAAR,wBAGA,0BAEU,IAAV,mCAEA,4BAEU,EAAV,4BA0BQ,EAAR,sCACQ,EAAR,cAGQ,EAAR,6CACQ,EAAR,yCACQ,EAAR,0BACQ,EAAR,mBACQ,EAAR,aAGI,UAvUJ,SAuUA,OACM,IAAN,OACM,OAAN,4BACQ,IAAR,8BAIU,EAAV,kDACU,EAAV,8CACU,EAAV,kDACU,EAAV,6DACA,YACU,EAAV,UAKI,eAxVJ,SAwVA,OACM,IAAN,OACM,OAAN,2BACQ,EAAR,mBACU,IAAV,iCAIY,EAAZ,kDACY,EAAZ,8CACY,EAAZ,kDACY,EAAZ,6DACA,YACY,cAMR,sBA3WJ,SA2WA,SAAM,IAAN,OACM,EAAN,gCAOQ,EAAR,eACQ,IAAR,kBAGA,yBACA,MAEU,GAAV,WAEQ,IAAR,6BACQ,EAAR,OAGQ,IAAR,IACA,YACA,YACA,KACA,KACA,oCACA,IACU,EAAV,OACU,EAAV,eACU,EAAV,iBACU,EAAV,YACU,EAAV,cAEQ,EAAR,gBACA,SAEQ,EAAR,IACA,SACA,CACU,KAAV,EACU,aAAV,EACU,eAAV,EACU,UAAV,IAGQ,EAAR,UACQ,IAAR,GACU,MAAV,EACU,MAAV,yBACU,aAAV,EACU,KAAV,EACU,OAAV,GAEQ,EAAR,mBAEQ,EAAR,iBACQ,EAAR,qBAGI,cAvaJ,SAuaA,GAEM,IAAN,kBACM,KAAN,cACM,IAAN,iBACA,OACA,CACQ,SAAR,WACQ,UAAR,YACQ,SAAR,WACQ,WAAR,aACQ,UAAR,YACQ,gBAAR,kBACQ,YAAR,sCACQ,aAAR,eACQ,gBAAR,+CAEA,OAEA,WACM,EAAN,wDACM,EAAN,SACM,EAAN,cACM,EAAN,gBACM,EAAN,UAEM,KAAN,iBACM,KAAN,gBACM,KAAN,kBAKI,oBAxcJ,SAwcA,OACA,wBAEQ,EAAR,QAGA,cACQ,KAAR,kBACA,SACA,mCACA,UACA,WAKM,IAAN,aACA,EAEQ,EAAR,sBAEA,EAEQ,EAAR,IACA,sBACA,WACA,YAIQ,EAAR,2BAIM,IAAN,aACA,EAEQ,EAAR,oBAEA,EAEQ,EAAR,IACA,WACA,WACA,YAEA,eAEQ,EAAR,2BAGA,eACQ,KAAR,mBAIM,IAAN,aAcM,GAbN,EAEQ,EAAR,gBAIQ,EAAR,qBAGM,KAAN,wBACM,KAAN,kBACM,KAAN,gCAEA,KACQ,KAAR,qBACQ,KAAR,iDAEA,CACQ,KAAR,6CACQ,KAAR,yBAEQ,IAAR,KACA,gBACU,EAAV,YAEQ,KAAR,oBAGM,KAAN,wBACM,KAAN,mDACM,KAAN,gDACM,KAAN,kBAEM,KAAN,4CAEI,kBApiBJ,WAqiBM,KAAN,yDACM,KAAN,2DACM,IAAN,+EACM,GAAN,EACQ,MAAR,sCAGI,OA5iBJ,WA6iBM,IAAN,2BACA,uBACA,QACU,KAAV,+BACU,KAAV,6BACU,KAAV,8BACU,KAAV,+DACU,KAAV,iCAGQ,KAAR,+BACQ,KAAR,0CAII,eA5jBJ,SA4jBA,GACM,KAAN,UACM,KAAN,uCACM,KAAN,UAEI,gBAjkBJ,SAikBA,GAEM,EAAN,oCAKI,0BAxkBJ,SAwkBA,GACM,IAAN,sCACM,MAAN,CACQ,GAAR,4CACQ,GAAR,+CAMI,aAllBJ,SAklBA,GAEM,IAAN,2BACM,GAAN,KACQ,OAAR,EAQM,IANA,IAAN,IACA,GACQ,QAAR,UACQ,QAAR,WAEA,SACA,eAGQ,GAFA,EAAR,WACQ,EAAR,yBACA,KACU,OAAV,EAIQ,GAFA,EAAR,aACQ,EAAR,yBACA,KACU,OAAV,EAKQ,GAHA,EAAR,WACQ,EAAR,WACQ,EAAR,yBACA,KACU,OAAV,EAIQ,GAFA,EAAR,aACQ,EAAR,yBACA,KACU,OAAV,EAEQ,EAAR,WAGM,OAAN,GAEI,iBAznBJ,SAynBA,GACM,IAAN,oCACA,gCAEM,KAAN,qBACA,8CACM,KAAN,0CACM,EAAN,MACM,EAAN,MACM,EACA,GAGA,KAAN,0CACM,KAAN,8CACM,KAAN,sBACM,KAAN,8BACM,KAAN,wCACQ,EAAR,qCAEM,KAAN,4CACM,KAAN,gCACA,oBACA,EACM,EACA,EACA,EACA,KAAN,aAEM,IAAN,sCAWM,OATA,KAAN,+BACM,KAAN,uCACM,KAAN,yBACM,KAAN,0BACM,KAAN,wCACQ,EAAR,qCAEM,KAAN,sBAEA,CACA,oBACA,oBACA,oBACA,sBAMI,kBA3qBJ,SA2qBA,GAGM,EAAN,iBACM,KAAN,8BACM,KAAN,+BAKI,mBArrBJ,SAqrBA,GACM,KAAN,2BACM,KAAN,yCACM,KAAN,0CAKI,iBA7rBJ,SA6rBA,GACM,KAAN,+CACM,KAAN,+CAKI,iBApsBJ,SAosBA,GACM,aAAN,qBACM,IAAN,uBACA,YACA,iBAEU,KAAV,oCACU,KAAV,oBAIU,KAAV,yCACU,KAAV,qBAII,yBAptBJ,SAotBA,GAAM,IAAN,OACA,kBACQ,EAAR,iBAEA,6EAIM,aAAN,qBACM,KAAN,sCAEQ,IAAR,oBACA,6BAIA,YAGA,OACY,EAAZ,gCACY,EAAZ,sCAKA,qBAGY,EAAZ,yCAIY,EAAZ,gCACY,EAAZ,yCAGA,OAKI,eA9vBJ,WA+vBM,IACN,SACA,SACQ,KAAR,uBACU,QAAV,sCAGM,IAAN,KACM,EAAN,mBAEM,EAAN,0BAEM,IAAN,KACA,KACA,KACM,KAAN,+BACQ,EAAR,SAEM,KAAN,gCACQ,IAAR,kBACA,KACU,EAAV,oBAGU,EAAV,yBAEQ,EAAR,8BACQ,IAAR,oBACQ,EAAR,gBACU,KAAV,sBACU,aAAV,iDACU,eAAV,mDACU,UAAV,2BACU,QAAV,qBAGM,EAAN,aACM,EAAN,YACM,EAAN,eACM,IAAN,KACM,KAAN,4BACQ,EAAR,MACU,MAAV,2BACU,SAAV,gBAGM,IAAN,GACQ,SAAR,+BACQ,OAAR,gCAEM,EAAN,UACQ,WAAR,aACQ,SAAR,EACQ,OAAR,GAEM,IAAN,KACM,KAAN,6BACQ,EAAR,MACU,SAAV,WACU,KAAV,OACU,WAAV,aACU,SAAV,WACU,SAAV,WACU,UAAV,YACU,UAAV,YACU,UAAV,YACU,YAAV,cACU,aAAV,eACU,gBAAV,kBACU,cAAV,gBACU,gBAAV,uBAGM,EAAN,UACM,IAAN,2BACM,OAAN,OAAM,CAAN,+BAEI,eA50BJ,WA60BM,IAAN,eACA,wCACA,8BACM,EAAN,sBACM,EAAN,OACM,EAAN,SAEI,YAp1BJ,SAo1BA,GACM,KAAN,4BACM,EAAN,gBAGE,cAn9BF,WAo9BI,OAAJ,4CC1jCkV,I,6FCQ9UC,EAAY,eACd,EACAtD,EACAqD,GACA,EACA,KACA,WACA,MAIa,aAAAC,EAAiB,QAQhC,IAAkBA,EAAW,CAACC,OAAA,KAAKC,QAAA,KAAMC,QAAA,KAAMC,QAAA,Q,oCC3B/C,W","file":"js/chunk-4a6f5fbd.0fab81e4.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"canvas-container\"},[_c('alert-snackbar'),_c('v-card',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.mouseHintShow),expression:\"mouseHintShow\"}],staticClass:\"pointer-tag pb-2 flex-column align-center\",attrs:{\"color\":\"#80808080\"}},[_c('v-flex',{staticClass:\"pa-2\",domProps:{\"innerHTML\":_vm._s(_vm.mouseHint)}}),_c('v-btn',{attrs:{\"tile\":\"\"},on:{\"click\":function($event){_vm.mouseHintShow=false}}},[_vm._v(_vm._s(_vm.$t(\"m.i.gotIt\")))])],1),_c('div',{ref:\"canvas-box\",staticClass:\"canvas-box\"},[_c('canvas',{ref:\"main-canvas\",attrs:{\"id\":\"main-canvas\"},on:{\"mousedown\":_vm.onCanvasMouseDown,\"mouseup\":_vm.onCanvasClickedOrTouched,\"dblclick\":_vm.onCanvasDblClick,\"touchstart\":_vm.onCanvasTouchStart,\"touchend\":_vm.onCanvasTouchEnd}})]),_c('material-dialog',{attrs:{\"neuron\":_vm.rightClickSelectedNeuron},on:{\"materialChanged\":_vm.render},model:{value:(_vm.rightClickMaterialDialogOpen),callback:function ($$v) {_vm.rightClickMaterialDialogOpen=$$v},expression:\"rightClickMaterialDialogOpen\"}}),_c('v-btn',{staticClass:\"panels-toggle-btn\",attrs:{\"color\":\"red\",\"fab\":\"\"},on:{\"click\":function($event){$event.stopPropagation();return _vm.togglePanel($event)}}},[_c('v-icon',{attrs:{\"color\":\"white\"}},[_vm._v(_vm._s(_vm.panelsOpen ? \"mdi-minus\" : \"mdi-plus\"))])],1),_c('div',{staticClass:\"panels-container elevation-3\",class:{'panels-container-mobile' : _vm.$store.state.isMobile},style:({\n        'max-height': (_vm.panelsOpen ? 'calc(100% - 40px)' : '0')\n    })},[(_vm.sceneIsOn)?_c('div',{staticClass:\"panels-wrapper\"},[_c('neuron-panel',{ref:\"neuronPanel\",attrs:{\"router\":\"viewer\",\"camera\":_vm.camera,\"controls\":_vm.controls,\"neuronList\":_vm.neuronList},on:{\"renderOnce\":_vm.render}}),_c('scene-panel',{ref:\"scenePanel\",attrs:{\"isViewer\":true,\"bgColor\":_vm.bgColor,\"lights\":_vm.lights,\"neuronList\":_vm.neuronList},on:{\"reload\":_vm.loadObj,\"downloadConfig\":_vm.saveConfigJson,\"loadCanvas\":_vm.loadCanvas,\"saveScreenshot\":_vm.saveScreenshot,\"bgColorChanged\":_vm.bgColorChanged,\"renderOnce\":_vm.render,\"controlsTypeChanged\":function($event){return _vm.controlsTypeChanged($event)}}})],1):_vm._e()])],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div class=\"canvas-container\">\r\n\r\n        <!-- alert dialog -->\r\n        <alert-snackbar></alert-snackbar>\r\n        <v-card\r\n        class=\"pointer-tag pb-2 flex-column align-center\"\r\n        color=\"#80808080\"\r\n        v-show=\"mouseHintShow\"\r\n        >\r\n            <v-flex class=\"pa-2\" v-html=\"mouseHint\"></v-flex>\r\n            <v-btn\r\n            tile\r\n            @click=\"mouseHintShow=false\">{{$t(\"m.i.gotIt\")}}</v-btn>\r\n        </v-card>\r\n        <!-- toggle buttons -->\r\n        \r\n\r\n        <!-- <loading-screen\r\n        ref=\"loading-screen\"\r\n        :loadingProgress=\"loadingProgress\"\r\n        @loadObj=\"loadObj\"></loading-screen> -->\r\n\r\n        <div class=\"canvas-box\" ref=\"canvas-box\">\r\n            <canvas\r\n            ref=\"main-canvas\"\r\n            id=\"main-canvas\"\r\n            @mousedown=\"onCanvasMouseDown\"\r\n            @mouseup=\"onCanvasClickedOrTouched\"\r\n            @dblclick=\"onCanvasDblClick\"\r\n            @touchstart=\"onCanvasTouchStart\"\r\n            @touchend=\"onCanvasTouchEnd\"\r\n            ></canvas>\r\n        </div>\r\n        <!-- <camera-joystick></camera-joystick> -->\r\n        <!-- <copyright-bar></copyright-bar> -->\r\n        <!-- opens material dialog on right click -->\r\n        <material-dialog\r\n        v-model=\"rightClickMaterialDialogOpen\"\r\n        :neuron=\"rightClickSelectedNeuron\"\r\n        @materialChanged=\"render\"></material-dialog>\r\n            <v-btn color=\"red\" class=\"panels-toggle-btn\" fab\r\n            @click.stop=\"togglePanel\">\r\n                <v-icon color=\"white\">{{panelsOpen ? \"mdi-minus\" : \"mdi-plus\"}}</v-icon>\r\n            </v-btn>\r\n        <div class=\"panels-container elevation-3\"\r\n        :class=\"{'panels-container-mobile' : $store.state.isMobile}\"\r\n        :style=\"{\r\n            'max-height': (panelsOpen ? 'calc(100% - 40px)' : '0')\r\n        }\">\r\n            <div class=\"panels-wrapper\"\r\n            v-if=\"sceneIsOn\">\r\n                <neuron-panel\r\n                ref=\"neuronPanel\"\r\n                router=\"viewer\"\r\n                :camera=\"camera\"\r\n                :controls=\"controls\"\r\n                :neuronList=\"neuronList\"\r\n                @renderOnce=\"render\"\r\n                ></neuron-panel>\r\n                <scene-panel\r\n                ref=\"scenePanel\"\r\n                @reload=\"loadObj\"\r\n                @downloadConfig=\"saveConfigJson\"\r\n                @loadCanvas=\"loadCanvas\"\r\n                @saveScreenshot=\"saveScreenshot\"\r\n                :isViewer=\"true\"\r\n                :bgColor=\"bgColor\"\r\n                @bgColorChanged=\"bgColorChanged\"\r\n                :lights=\"lights\"\r\n                :neuronList=\"neuronList\"\r\n                @renderOnce=\"render\"\r\n                @controlsTypeChanged=\"controlsTypeChanged($event)\"></scene-panel>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport * as THREE from 'three';\r\nimport { TrackballControls } from 'three/examples/jsm/controls/TrackballControls';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport {\r\n    OBJLoader2\r\n} from 'three/examples/jsm/loaders/OBJLoader2';\r\n// import LoadingScreen from './LoadingScreen';\r\nimport AlertSnackbar from './dialogs/AlertSnackbar';\r\n// import CameraJoystick from './CameraJoystick';\r\nimport ScenePanel from './panels/ScenePanel';\r\nimport NeuronPanel from './panels/NeuronPanel';\r\n// import CopyrightBar from './CopyrightBar';\r\nimport MaterialDialog from './dialogs/MaterialDialog';\r\n\r\nimport CommonMethods from './js/Common';\r\nimport * as Shader from './shaders';\r\nimport { generateTextSprite } from './js/threejs-text-sprite';\r\nimport { download } from './js/FileSaver';\r\nimport { Vector3 } from 'three';\r\nimport axios from \"axios\";\r\nimport JSZip from 'jszip';\r\nimport JSZipUtils from 'jszip-utils';\r\n\r\nexport default {\r\n    name: 'MyCanvas',\r\n    components: {\r\n        // LoadingScreen,\r\n        AlertSnackbar,\r\n        // CameraJoystick,\r\n        // CopyrightBar,\r\n        MaterialDialog,\r\n        ScenePanel,\r\n        NeuronPanel\r\n    },\r\n    data: function() {\r\n        return {\r\n            modelPath: undefined,\r\n            // scene & camera\r\n            fov: 30,\r\n            near: 0.1,//最小范围\r\n            far: 10000,//最大范围\r\n            \r\n            canvasWidth: 600,\r\n            canvasHeight: 400,\r\n\r\n            canvas: undefined,\r\n            canvasBox: undefined,\r\n            camera: undefined,\r\n            scene: undefined,\r\n            renderer: undefined,\r\n            controls: undefined,\r\n\r\n            three: undefined,\r\n\r\n            // scene\r\n            bgColor: '#000000',\r\n            blackColor: '#000000',\r\n            // true if the scene is loaded and could be rendered\r\n            sceneIsSet: false,\r\n            // to prevent scene, renderers and camera to mount repeatedly\r\n            sceneIsFirstSet: false,\r\n            sceneIsOn: true,\r\n            panelsOpen: false,\r\n\r\n            // light\r\n            lights: [\r\n                {\r\n                    color: undefined,\r\n                    strength: 1,\r\n                    outColor: undefined\r\n                },\r\n                {\r\n                    color: undefined,\r\n                    strength: 0.5,\r\n                    direction: new Vector3(1.0, 0.0, 0.0),\r\n                    outColor: undefined\r\n                },\r\n                {\r\n                    color: undefined,\r\n                    strength: 0.5,\r\n                    direction: new Vector3(-1.0, 0.0, 0.0),\r\n                    outColor: undefined\r\n                }\r\n            ],\r\n\r\n\r\n            // obj\r\n            loadedObj: undefined,\r\n            neuronList: [],\r\n            groupList: [],\r\n            defaultGroupText: this.$t(\"m.i.defaultGroupText\"),\r\n            neuronCount: 0,\r\n\r\n            // obj loading\r\n            loadingProgress: 0,\r\n            individualUnzippingProgress: [],\r\n            individualLoadingProgress: [],\r\n\r\n            // mouse/touch events\r\n            clickTimeoutId: 0,\r\n            // picking objs\r\n            pickScene: undefined,\r\n            // target for rendering id and depth info, when isInfo is set to true\r\n            pickingTexture: new THREE.WebGLRenderTarget(1, 1, {\r\n                type: THREE.FloatType}),\r\n            // used for reading one single pixel at the position of the mouse\r\n            pixelBuffer: new Float32Array(4),\r\n            // used for looking up idValue's corresponding neuron OR TAG\r\n            elementDict: {},\r\n            rightClickMaterialDialogOpen: false,\r\n            rightClickSelectedNeuron: undefined,\r\n            touchTimeStamp: 0,\r\n\r\n            // tags\r\n            tagList: [],\r\n\r\n            // used for detecting whether mouseup/touch event is from a single click or drag\r\n            cvsMouseOrTouchPosX: 0,\r\n            cvsMouseOrTouchPosY: 0,\r\n\r\n            // for recording the neuronConfig data\r\n            fileList: [],\r\n\r\n            mouseHint: this.$store.state.isMobile ?\r\n                this.$t(\"m.i.mouseHintMobile\")\r\n                :\r\n                this.$t(\"m.i.mouseHintDesktop\"),\r\n            mouseHintShow: true\r\n        }\r\n    },\r\n    mounted() {\r\n        this.canvas = this.$refs['main-canvas'];\r\n        this.canvasBox = this.$refs['canvas-box'];\r\n        window.onresize = this.render;\r\n        window.onbeforeunload = function (event) {\r\n            var e = event || window.event;\r\n            // 兼容IE8和Firefox 4之前的版本\r\n            if (e) {\r\n                event.returnValue = this.$t(\"m.a.qWindowsClose\");\r\n            }\r\n            // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+\r\n            return this.$t(\"m.a.qWindowsClose\");\r\n        }\r\n        this.loadObj();\r\n    },\r\n    methods: {\r\n        loadObj() {\r\n            // load neuronConfig\r\n            var path = \"/model/config.json\";\r\n            axios.get('/configPath.txt').then(res => {\r\n                path = res.data;\r\n                this.modelPath = path.replace(/\\/[^/]+$/,''); // default: '/model'\r\n            }).finally(() => {\r\n                axios.get(path).then(res => {\r\n                    this.sceneIsOn = true;\r\n                    this.loadCanvas(res.data);\r\n                });\r\n            })\r\n        },\r\n        getRomoteZipFiles(url, index, total) {\r\n            const self = this;\r\n            return new Promise(function(resolve, reject) {\r\n                //  step1 请求文件\r\n                JSZipUtils.getBinaryContent(url, {\r\n                    callback: function(err, data) {\r\n                        if (err) {\r\n                            reject(err);\r\n                        } else {\r\n                            // loading zip file & unzipping done\r\n                            resolve(data);\r\n                        }\r\n                    },\r\n                    progress: (xhr) => {\r\n                        self.loadingProgress -= (self.individualUnzippingProgress[index] / total);\r\n                        self.individualUnzippingProgress[index] = xhr.loaded / xhr.total;\r\n                        self.loadingProgress += (self.individualUnzippingProgress[index] / total);\r\n                    }\r\n                });\r\n            })\r\n            .then(function(files) {\r\n                //  step2 解压\r\n                return JSZip.loadAsync(files);\r\n            })\r\n            .then((files) => {\r\n                const fileNames = Object.keys(files.files);\r\n                return files;\r\n            })\r\n        },\r\n        loadCanvas(neuronConfig) {\r\n\r\n            this.sceneIsSet = false;\r\n\r\n            // set canvas\r\n            this.canvasWidth = this.canvasBox.getBoundingClientRect().width;\r\n            this.canvasHeight = this.canvasBox.getBoundingClientRect().height;\r\n\r\n            this.canvas.style.width =  this.canvasWidth;\r\n            this.canvas.style.height =  this.canvasHeight;\r\n\r\n            if(!this.sceneIsFirstSet) {\r\n                // set 2 scenes (default + pick)\r\n                this.scene = new THREE.Scene();\r\n                this.pickScene = new THREE.Scene();\r\n                this.pickScene.background = new THREE.Color(0);\r\n            }\r\n            this.scene.children.length = [];\r\n            this.pickScene.children.length = [];\r\n            // set light\r\n            this.lights.forEach((l, i)=> {\r\n                // load lighting settings from neuronConfig\r\n                if(neuronConfig.scene) {\r\n                    let neuronConfigLighting = neuronConfig.scene.lighting[i];\r\n                    l.color = new THREE.Color(neuronConfigLighting.color);\r\n                    l.strength = neuronConfigLighting.strength;\r\n                }\r\n                else {\r\n                    l.color = new THREE.Color(1.0, 1.0, 1.0);\r\n                }\r\n                l.outColor = new Vector3(l.color.r, l.color.g, l.color.b);\r\n                l.outColor.multiplyScalar(l.strength);\r\n            })\r\n            // set renderer\r\n            if(!this.sceneIsFirstSet) {\r\n                this.renderer = new THREE.WebGLRenderer({\r\n                    canvas: this.canvas,\r\n                    antialias: true, // 是否执行抗锯齿\r\n                    preserveDrawingBuffer: true // snapshot\r\n                });\r\n            }\r\n            this.renderer.setSize(this.canvasWidth, this.canvasHeight);\r\n            this.renderer.renderLists.dispose();\r\n            // cull face\r\n            // this.renderer.setFaceCulling(THREE.CullFaceFront,THREE.FrontFaceDirectionCW);\r\n\r\n            // set camera\r\n            if(neuronConfig.scene && neuronConfig.scene.camera) {\r\n                this.controlsTypeChanged(1, neuronConfig.scene.camera, true);\r\n            }\r\n            else {\r\n                this.controlsTypeChanged(1, undefined, false);\r\n            }\r\n\r\n            // set a parent object\r\n            if(this.loadedObj && this.loadedObj.children) {\r\n                this.loadedObj.children.forEach(c => {\r\n                    c = null;\r\n                })\r\n                this.loadedObj = null;\r\n            }\r\n            this.loadedObj = new THREE.Object3D();\r\n\r\n            this.elementDict = {};\r\n            \r\n            // set tags (sprites)\r\n            this.tagIdCount = 500;\r\n            this.tagList.length = 0;\r\n            if(neuronConfig.tags) {\r\n                neuronConfig.tags.forEach((tagInfo) => {\r\n                    this.addTagToScene(tagInfo);\r\n                })\r\n            }\r\n\r\n            // load obj\r\n            // clears all variables:\r\n            this.panelsOpen = false;\r\n            this.mouseHintShow = true;\r\n            this.loadingProgress = 0;   // clears progress\r\n            this.$store.commit(\"loadingProgressChanged\", this.loadingProgress);\r\n            this.neuronList.length = 0; // clears neuronList\r\n            this.fileList.length = 0; // clears fileList\r\n            this.groupList.length = 0;  // clears groupList\r\n            this.neuronCount = 0;\r\n            // sets group\r\n            var hasDefaultGroupText = false;\r\n            if(neuronConfig.groups) {\r\n                for(let group in neuronConfig.groups) {\r\n                    if(group == this.defaultGroupText) {\r\n                        hasDefaultGroupText = true;\r\n                    }\r\n                    this.groupList.push(group);\r\n                }\r\n            }\r\n            if(!hasDefaultGroupText) {\r\n                this.groupList.push(this.defaultGroupText);\r\n            }\r\n\r\n            this.$store.commit(\"loadingScreenFadeIn\");\r\n\r\n            // counts the total number of objs\r\n            // ( = number of files with '.obj' suffix + sum of numbers of objs in each .zip )\r\n            this.individualLoadingProgress = 0;\r\n\r\n            // saves each obj str in a dictionary with key = zipName+'_'+fileName\r\n            var objAsyncStrsFromZips = {};\r\n            var promises = [];\r\n\r\n            // count the number of zip files\r\n            var zipFileCount = 0;\r\n\r\n            neuronConfig.fileList.forEach((fileUrl, index) => {\r\n                this.fileList.push(fileUrl);\r\n                const suffix = CommonMethods.getFileType(fileUrl);\r\n                if(suffix == \".zip\") {\r\n                    zipFileCount += 1;\r\n                }\r\n            });\r\n            \r\n            if(zipFileCount > 0) {\r\n                // has files to unzip\r\n                this.individualUnzippingProgress = new Float32Array(zipFileCount);\r\n                this.$store.state.loadingPhase = 0;\r\n            }\r\n            else {\r\n                // all files are objs\r\n                this.$store.state.loadingPhase = 1;\r\n            }\r\n\r\n            var zipFileIndex = 0;\r\n\r\n            neuronConfig.fileList.forEach((fileUrl, index) => {\r\n                this.fileList.push(fileUrl);\r\n                \r\n                const suffix = CommonMethods.getFileType(fileUrl);\r\n                if(suffix == \".zip\") {\r\n                    // get zip content\r\n                    const zipPath = this.modelPath + `/objects/${fileUrl}`;\r\n                    console.log(zipPath)\r\n                    var readZipPromise = this.getRomoteZipFiles(zipPath, zipFileIndex, zipFileCount).then(files => {\r\n                        const fileNamesInZip = Object.keys(files.files);\r\n                        fileNamesInZip.forEach(fileName => {\r\n                            const zippedFileSuffix = CommonMethods.getFileType(fileName);\r\n                            if(zippedFileSuffix == \".obj\") {\r\n                                const originalName = fileUrl + '_' + fileName;\r\n                                var objAsyncStr = files.file(fileName).async(\"string\");\r\n                                objAsyncStrsFromZips[originalName] = objAsyncStr;\r\n                                this.individualLoadingProgress += 1;\r\n                            }\r\n                        });\r\n                    });\r\n                    promises.push(readZipPromise);\r\n                    zipFileIndex += 1;\r\n                }\r\n                else if(suffix == \".obj\") {\r\n                    this.individualLoadingProgress += 1;\r\n                }\r\n            });\r\n\r\n            Promise.all(promises).then(() => {\r\n                // when all models have been loaded\r\n                console.log(\"unzipped\");\r\n            }).catch((error) => {\r\n                // some objects failed to load\r\n                this.$store.commit(\"alert\", {\r\n                    content: this.$t(\"m.a.fileUnableToUnzip\") + error,\r\n                    timeout: 1000000\r\n                });\r\n            }).finally(() => {\r\n                // all zip files are read\r\n                this.$store.state.loadingPhase = 1;\r\n                this.loadingProgress = 0;\r\n                this.$store.commit(\"loadingProgressChanged\", this.loadingProgress);\r\n                this.individualLoadingProgress\r\n                    = new Float32Array(this.individualLoadingProgress);\r\n                this.loadModels(objAsyncStrsFromZips, neuronConfig);\r\n            });\r\n        },\r\n\r\n        loadModels(objAsyncStrsFromZips, neuronConfig) {\r\n            var promises = [];\r\n\r\n            var self = this;\r\n            \r\n            // create a dictionary storing group info\r\n            const groupData = {};\r\n            for(let key in neuronConfig.groups) {\r\n                neuronConfig.groups[key].forEach(val => {\r\n                    groupData[val] = key;\r\n                })\r\n            }\r\n\r\n            var objIndex = 0;\r\n\r\n            // read and load objs in .zip files\r\n            Object.keys(objAsyncStrsFromZips).forEach((key) => {\r\n                const objAsyncStr = objAsyncStrsFromZips[key];\r\n                let p = this.loadModelLocal(\r\n                    objAsyncStr,\r\n                    objIndex,\r\n                    this.individualLoadingProgress.length\r\n                ).then(result => {\r\n                    this.addLoadedResultsToObj(result, neuronConfig, key, groupData);\r\n                });\r\n                promises.push(p);\r\n                objIndex += 1;\r\n            });\r\n\r\n            // read and load .obj files from neuronConfig\r\n            neuronConfig.fileList.forEach((fileUrl, index) => {\r\n                \r\n                var suffix = CommonMethods.getFileType(fileUrl);\r\n\r\n                if(suffix == \".obj\") {\r\n                    // file is obj: read and load .obj file with loadModel\r\n                    let p = this.loadModel(\r\n                        this.modelPath + `/objects/${fileUrl}`,\r\n                        objIndex,\r\n                        this.individualLoadingProgress.length\r\n                    ).then(result => {\r\n                        this.addLoadedResultsToObj(result, neuronConfig, fileUrl, groupData);\r\n                    })\r\n                    promises.push(p);\r\n                    objIndex += 1;\r\n                }\r\n            });\r\n\r\n            Promise.all(promises).then(() => {\r\n                // when all models have been loaded\r\n                console.log(\"files loaded\");\r\n            }).catch((error) => {\r\n                // some objects failed to load\r\n                this.$store.commit(\"alert\", {\r\n                    content: this.$t(\"m.a.fileUnableToLoad\") + error,\r\n                    timeout: 1000000\r\n                });\r\n            }).finally(() => {\r\n                // scene is loaded\r\n                this.scene.add(this.loadedObj);\r\n                \r\n                // if camera position is unset (no config)\r\n                if(!neuronConfig.scene || !neuronConfig.scene.camera) {\r\n\r\n                    var boundingbox = new THREE.BoxHelper(this.loadedObj, 0xff0000);\r\n    \r\n                    var boundingSphere = boundingbox.geometry.boundingSphere;\r\n                    \r\n                    this.controlsTypeChanged(1, boundingSphere, false);\r\n                }\r\n\r\n                // if(neuronConfig.scene && neuronConfig.scene.camera) {\r\n                //     // if camera's position and target is defined in config\r\n                //     this.controls.target.fromArray(neuronConfig.scene.camera.target);\r\n                //     this.camera.position.fromArray(neuronConfig.scene.camera.position);\r\n                //     this.controls.position0.copy(this.camera.position);\r\n                // }\r\n                // else {\r\n                //     // else: position camera to get object into view\r\n                //     var boundingbox = new THREE.BoxHelper(this.loadedObj, 0xff0000);\r\n    \r\n                //     var boundingSphere = boundingbox.geometry.boundingSphere;\r\n                //     if(boundingSphere) {\r\n                //         this.controls.target.copy(boundingSphere.center);\r\n                //         this.camera.position.set(boundingSphere.center.x - 2 * boundingSphere.radius,\r\n                //                                 boundingSphere.center.y,\r\n                //                                 boundingSphere.center.z);\r\n                //         this.controls.position0.copy(this.camera.position);\r\n                //     }\r\n                // }\r\n                // this.controlsTypeChanged(1);\r\n                // this.controls.update();\r\n                \r\n                // loading ends, hide loading screen\r\n                this.$store.commit(\"loadingScreenFadeOut\");\r\n                this.sceneIsSet = true;\r\n\r\n                // sets bg color and render once; render() is within bgColorChanged\r\n                this.bgColor = neuronConfig.scene ? neuronConfig.scene.background : \"#000000\";\r\n                this.$refs[\"scenePanel\"].bgColorVal = this.bgColor;\r\n                this.bgColorChanged(this.bgColor);\r\n                this.sceneIsFirstSet = true;\r\n                this.render();\r\n            });\r\n        },\r\n        loadModel(url, index, total) {\r\n            let self = this;\r\n            return new Promise( function( resolve, reject ){\r\n                new OBJLoader2().load(url, resolve, (xhr) => {\r\n                        // the following assignments calculate total loading process (loadingProgress)\r\n                        // by recording loading %s of each obj file\r\n                        // and sum them (since files are being asynchronously loaded)\r\n                        self.loadingProgress -= (self.individualLoadingProgress[index] / total);\r\n                        self.individualLoadingProgress[index] = xhr.loaded / xhr.total;\r\n                        self.loadingProgress += (self.individualLoadingProgress[index] / total);\r\n                        self.$store.commit(\"loadingProgressChanged\", self.loadingProgress);\r\n                    }, (e) => {\r\n                        reject(url);\r\n                    }\r\n                );\r\n            });\r\n        },\r\n        loadModelLocal(objAsyncStr, index, total) {\r\n            let self = this;\r\n            return new Promise( function( resolve, reject ){\r\n                objAsyncStr.then(objStr => {\r\n                    new OBJLoader2().loadStr(objStr, resolve, (xhr) => {\r\n                            // the following assignments calculate total loading process (loadingProgress)\r\n                            // by recording loading %s of each obj file\r\n                            // and sum them (since files are being asynchronously loaded)\r\n                            self.loadingProgress -= (self.individualLoadingProgress[index] / total);\r\n                            self.individualLoadingProgress[index] = xhr.loaded / xhr.total;\r\n                            self.loadingProgress += (self.individualLoadingProgress[index] / total);\r\n                            self.$store.commit(\"loadingProgressChanged\", self.loadingProgress);\r\n                        }, (e) => {\r\n                            reject();\r\n                        }\r\n                    );\r\n                })\r\n            });\r\n        },\r\n        addLoadedResultsToObj(result, neuronConfig, key, groupData) {\r\n            result.children.forEach((neuron, neuron_index) => {\r\n                // 1. sets each child's material\r\n                // 2. stores them in neuronList\r\n                // 3. assigns each child with a unique idValue (used for picking)\r\n                //    and stores the pair in elementDict\r\n                // 4. sets the name of each child\r\n                // 5. assigns each child with a group (default: \"default group\")\r\n                this.neuronCount += 1;\r\n                let idValue = this.neuronCount + 1;\r\n                // name\r\n                // replace the name for predifined alias, if there's any\r\n                let originalName = CommonMethods.sansFileType(key);\r\n                if(neuron_index > 0) {\r\n                    // i.e. neuron file_2, neuron file_3\r\n                    originalName += ('_' + (neuron_index+1));\r\n                }\r\n                let neuronName = neuronConfig.aliases ? (neuronConfig.aliases[originalName] || originalName) : originalName;\r\n                neuron.name = neuronName;\r\n                // neuron.geometry.computeFaceNormals();\r\n                // get material setting from neuronConfig\r\n                let nType = 1;\r\n                let nprimaryColor = \"#b0b0b0\";\r\n                let nSecondaryColor = \"#000000\";\r\n                let nShininess = 16;\r\n                let nVisible = true;\r\n                let nMatSetting = neuronConfig.materials ? neuronConfig.materials[neuronName] : undefined;\r\n                if(nMatSetting) {\r\n                    nType = nMatSetting.type;\r\n                    nprimaryColor = nMatSetting.primaryColor;\r\n                    nSecondaryColor = nMatSetting.secondaryColor;\r\n                    nShininess = nMatSetting.shininess;\r\n                    nVisible = (nMatSetting.visible == true);\r\n                }\r\n                neuron.material = Shader.createMainMaterial(\r\n                    this.camera,\r\n                    // it **SEEMS** pixel reading could only restore value up to 6~7 decimal places\r\n                    idValue / 1000,\r\n                    this.lights,\r\n                    {\r\n                        type: nType,\r\n                        primaryColor: nprimaryColor,\r\n                        secondaryColor: nSecondaryColor,\r\n                        shininess: nShininess\r\n                    }\r\n                );\r\n                neuron.visible = nVisible;\r\n                let newNeuron = {\r\n                    index: idValue,\r\n                    group: groupData[neuronName] || this.defaultGroupText,\r\n                    originalName: originalName,\r\n                    name: neuronName,\r\n                    neuron: neuron,\r\n                };\r\n                this.neuronList.push(newNeuron);\r\n                // save neuron to a dictionary with a corresponding unique idValue (for picking)\r\n                this.elementDict[idValue] = newNeuron;\r\n                this.loadedObj.add(neuron);\r\n            });\r\n        },\r\n        addTagToScene(tagInfo) {\r\n            // create a new sprite\r\n            var idValue = this.tagIdCount;\r\n            this.tagIdCount += 1;\r\n            var generatedSpriteInfo = generateTextSprite(\r\n                tagInfo.text,\r\n                {\r\n                    fontSize: tagInfo.fontSize,\r\n                    fontColor: tagInfo.fontColor,\r\n                    fontBold: tagInfo.fontBold,\r\n                    fontItalic: tagInfo.fontItalic,\r\n                    textAlign: tagInfo.textAlign,\r\n                    borderThickness: tagInfo.borderThickness,\r\n                    borderColor: tagInfo.hasBorder ? tagInfo.borderColor:'#00000000',\r\n                    borderRadius: tagInfo.borderRadius,\r\n                    backgroundColor: tagInfo.hasBackground ? tagInfo.backgroundColor:'#00000000'\r\n                },\r\n                idValue / 1000\r\n            );\r\n            var sprite = generatedSpriteInfo.sprite;\r\n            sprite.position.set(tagInfo.position[0], tagInfo.position[1], tagInfo.position[2]);\r\n            tagInfo.sprite = sprite;\r\n            tagInfo.ruler = generatedSpriteInfo.ruler;\r\n            tagInfo.canvas = generatedSpriteInfo.canvas;\r\n            tagInfo.idValue = idValue;\r\n            // save tag to a dictionary with a corresponding unique idValue (for picking)\r\n            this.elementDict[idValue] = tagInfo;\r\n            this.tagList.push(tagInfo);\r\n            this.loadedObj.add(sprite);\r\n        },\r\n        /**\r\n         * @param presets either config.scene.camera or boundingSphere or undefiend\r\n         */\r\n        controlsTypeChanged(controlsTypeValue, presets, isCameraPreset) {\r\n            if(isCameraPreset && presets && presets.type !== undefined) {\r\n                // overrides default controlsTypeValue if it's configured in presets\r\n                controlsTypeValue = presets.type;\r\n            }\r\n            // generate camera\r\n            if(!this.camera) {\r\n                this.camera = new THREE.PerspectiveCamera(\r\n                    this.fov,\r\n                    this.canvasWidth/this.canvasHeight,\r\n                    this.near,\r\n                    this.far\r\n                );\r\n            }\r\n\r\n            // position\r\n            var tempCameraPosition = new Vector3();\r\n            if(isCameraPreset) {\r\n                // has config\r\n                tempCameraPosition.fromArray(presets.position);\r\n            }\r\n            else if(presets) {\r\n                // has boundingSphere\r\n                tempCameraPosition.set(\r\n                    presets.center.x - 2 * presets.radius,\r\n                    presets.center.y,\r\n                    presets.center.z);\r\n            }\r\n            else {\r\n                // change camera type, or no preset is present\r\n                tempCameraPosition.copy(this.camera.position);\r\n            }\r\n\r\n            // target\r\n            var tempControlsTarget = new Vector3();\r\n            if(isCameraPreset) {\r\n                // has config\r\n                tempControlsTarget.fromArray(presets.target);\r\n            }\r\n            else if(presets) {\r\n                // has boundingSphere\r\n                tempControlsTarget.set(\r\n                    presets.center.x,\r\n                    presets.center.y,\r\n                    presets.center.z);\r\n            }\r\n            else if(this.controls) {\r\n                // change camera type, or no preset is present\r\n                tempControlsTarget.copy(this.controls.target);\r\n            }\r\n\r\n            if(this.controls) {\r\n                this.controls.dispose();\r\n            }\r\n            \r\n            // up\r\n            var tempCameraUp = new Vector3();\r\n            if(isCameraPreset) {\r\n                // has config\r\n                tempCameraUp.fromArray(presets.up);\r\n            }\r\n            else {\r\n                // change camera type, or no preset is present\r\n                tempCameraUp.copy(this.camera.up);\r\n            }\r\n\r\n            this.camera.position.copy(tempCameraPosition);\r\n            this.camera.up.copy(tempCameraUp);\r\n            this.camera.updateProjectionMatrix();\r\n\r\n            if(controlsTypeValue == 0) {\r\n                this.camera.up.set(0, 1, 0);\r\n                this.controls = new OrbitControls(this.camera, this.canvas);\r\n            }\r\n            else {\r\n                this.controls = new TrackballControls(this.camera, this.canvas);\r\n                this.controls.staticMoving = true;\r\n                // set panSpeed\r\n                var panSpeed = 0.5;\r\n                if(isCameraPreset && presets.panSpeed) {\r\n                    panSpeed = presets.panSpeed;\r\n                }\r\n                this.controls.panSpeed = panSpeed;\r\n            }\r\n            \r\n            this.controls.target.copy(tempControlsTarget);\r\n            this.controls.removeEventListener('change', this.render);\r\n            this.controls.addEventListener('change', this.render);\r\n            this.controls.update();\r\n\r\n            this.$store.commit(\"setControls\", this.controls);\r\n        },\r\n        renderNeedsResize() {\r\n            this.canvasWidth = this.canvasBox.getBoundingClientRect().width;\r\n            this.canvasHeight = this.canvasBox.getBoundingClientRect().height;\r\n            const needResize = this.canvas.width !== this.canvasWidth || this.canvas.height !== this.canvasHeight;\r\n            if (needResize) {\r\n                return [this.canvasWidth, this.canvasHeight];\r\n            }\r\n        },\r\n        render() {\r\n            let newSize = this.renderNeedsResize();\r\n            if(this.sceneIsSet) {\r\n                if (newSize !== undefined) {\r\n                    this.renderer.setSize(newSize[0], newSize[1], false);\r\n                    this.canvas.style.width = newSize[0] + 'px';\r\n                    this.canvas.style.height = newSize[1] + 'px';\r\n                    this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\r\n                    this.camera.updateProjectionMatrix();\r\n                    // this.controls.handleResize();\r\n                }\r\n                this.renderer.setRenderTarget(null);\r\n                this.renderer.render(this.scene, this.camera);\r\n            }\r\n        },\r\n        // scene\r\n        bgColorChanged(color) {\r\n            this.bgColor = color;\r\n            this.renderer.setClearColor(this.bgColor, 1.0);\r\n            this.render();\r\n        },\r\n        onTransitionEnd( event ) {\r\n            // event.target.remove();\r\n            event.target.classList.remove( 'fade-in' );\r\n        },\r\n        /**\r\n         * used for picking element with mouse\r\n         */\r\n        getCanvasRelativePosition(event) {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            return {\r\n                x: (event.clientX - rect.left) * this.canvas.width  / rect.width,\r\n                y: (event.clientY - rect.top ) * this.canvas.height / rect.height,\r\n            };\r\n        },\r\n        /**\r\n         * search for any valid neuron info within a certain offset from original coords\r\n         */\r\n        getClickInfo(e) {\r\n            // original position\r\n            var originalInfo = this.getClickInfoOnce(e);\r\n            if(originalInfo[0]) {\r\n                return originalInfo;\r\n            }\r\n            var maxOffset = 5;\r\n            var tempE = {\r\n                clientX: e.clientX,\r\n                clientY: e.clientY\r\n            };\r\n            var tempInfo = undefined;\r\n            for(let tempOffset = 1; tempOffset <= maxOffset; tempOffset += 1) {\r\n                tempE.clientX -= tempOffset;\r\n                tempInfo = this.getClickInfoOnce(tempE);\r\n                if(tempInfo[0]) {\r\n                    return tempInfo;\r\n                }\r\n                tempE.clientX += 2 * tempOffset;\r\n                tempInfo = this.getClickInfoOnce(tempE);\r\n                if(tempInfo[0]) {\r\n                    return tempInfo;\r\n                }\r\n                tempE.clientX -= tempOffset;\r\n                tempE.clientY -= tempOffset;\r\n                tempInfo = this.getClickInfoOnce(tempE);\r\n                if(tempInfo[0]) {\r\n                    return tempInfo;\r\n                }\r\n                tempE.clientY += 2 * tempOffset;\r\n                tempInfo = this.getClickInfoOnce(tempE);\r\n                if(tempInfo[0]) {\r\n                    return tempInfo;\r\n                }\r\n                tempE.clientY -= tempOffset;\r\n            }\r\n            // if no valid object is within the offset\r\n            return originalInfo;\r\n        },\r\n        getClickInfoOnce(e) {\r\n            const clickPos = this.getCanvasRelativePosition(e);\r\n            const pixelRatio = this.renderer.getPixelRatio();\r\n            // pick\r\n            this.camera.setViewOffset(\r\n                this.renderer.getContext().drawingBufferWidth,   // full width\r\n                this.renderer.getContext().drawingBufferHeight,  // full top\r\n                clickPos.x * pixelRatio | 0,             // rect x\r\n                clickPos.y * pixelRatio | 0,             // rect y\r\n                1,                                          // rect width\r\n                1,                                          // rect height\r\n            );\r\n            // renders info to pickingTexture\r\n            this.renderer.setClearColor(this.blackColor, 1.0);\r\n            this.renderer.setRenderTarget(this.pickingTexture);\r\n            this.renderer.antialias = false;\r\n            this.pickScene.add(this.loadedObj);\r\n            this.loadedObj.children.forEach(n => {\r\n                n.material.uniforms.isInfo.value = true;\r\n            })\r\n            this.renderer.render(this.pickScene, this.camera);\r\n            this.renderer.readRenderTargetPixels(\r\n                this.pickingTexture,\r\n                0,   // x\r\n                0,   // y\r\n                1,   // width\r\n                1,   // height\r\n                this.pixelBuffer);\r\n            // gets the picked neuron\r\n            var restoredIdValue = Math.round(this.pixelBuffer[0] * 1000);\r\n            // renders scene back to original canvas\r\n            this.renderer.setRenderTarget(null);\r\n            this.renderer.setClearColor(this.bgColor, 1.0);\r\n            this.camera.clearViewOffset();\r\n            this.scene.add(this.loadedObj);\r\n            this.loadedObj.children.forEach(n => {\r\n                n.material.uniforms.isInfo.value = false;\r\n            })\r\n            this.renderer.antialias = true;\r\n\r\n            return [\r\n                this.elementDict[restoredIdValue],\r\n                this.pixelBuffer[1],\r\n                this.pixelBuffer[2],\r\n                this.pixelBuffer[3]\r\n            ];\r\n        },\r\n        /**\r\n         * records touch position when mouse is down\r\n         */\r\n        onCanvasMouseDown(e) {\r\n            // preventDefault: an operation I've removed in node_module's OrbitControls (line 827)\r\n            // (see patch file)\r\n            e.preventDefault();\r\n            this.cvsMouseOrTouchPosX = e.clientX;\r\n            this.cvsMouseOrTouchPosY = e.clientY;\r\n        },\r\n        /**\r\n         * used when app is opened in mobile devices; records touch position\r\n         */\r\n        onCanvasTouchStart(e) {\r\n            this.touchTimeStamp = e.timeStamp;\r\n            this.cvsMouseOrTouchPosX = e.touches[0].clientX;\r\n            this.cvsMouseOrTouchPosY = e.touches[0].clientY;\r\n        },\r\n        /**\r\n         * pass changedTouches position to onCanvasClickedOrTouched\r\n         */\r\n        onCanvasTouchEnd(e) {\r\n            this.touchTimeStamp = e.timeStamp - this.touchTimeStamp;\r\n            this.onCanvasClickedOrTouched(e.changedTouches[0]);\r\n        },\r\n        /**\r\n         * when dblclick: reposition camera target?\r\n         */\r\n        onCanvasDblClick(e) {\r\n            clearTimeout(this.clickTimeoutId);\r\n            var info = this.getClickInfo(e);\r\n            if(info[0]) {\r\n                if(info[0].neuron !== undefined) {\r\n                    // clicked on neuron\r\n                    this.controls.target.set(info[1],info[2],info[3]);\r\n                    this.controls.update();\r\n                }\r\n                else {\r\n                    // clicked on tag\r\n                    this.controls.target.fromArray(info[0].position);\r\n                    this.controls.update();\r\n                }\r\n            }\r\n        },\r\n        onCanvasClickedOrTouched(e) {\r\n            if(e.preventDefault) {\r\n                e.preventDefault();\r\n            }\r\n            if(e.clientX !== this.cvsMouseOrTouchPosX || e.clientY !== this.cvsMouseOrTouchPosY) {\r\n                // has been dragged; not a single click\r\n                return;\r\n            }\r\n            clearTimeout(this.clickTimeoutId);\r\n            this.clickTimeoutId = setTimeout(() => {\r\n                // is single click\r\n                var info = this.getClickInfo(e);\r\n                if(!info[0] || info[0].neuron === undefined) {\r\n                    // didn't click on neuron or clicked on tag\r\n                    return;\r\n                }\r\n                if(e.button == 2) {\r\n                    // on right click\r\n                    // sets neuron material\r\n                    if(info[0]) {\r\n                        this.rightClickMaterialDialogOpen = true;\r\n                        this.rightClickSelectedNeuron = info[0].neuron;\r\n                    }\r\n                }\r\n                else {\r\n                    // on wheel click, or left click, or touch\r\n                    if(this.touchTimeStamp < 300) {\r\n                        // click/short touch\r\n                        // let neuron panel have the picked neuron and do its operation\r\n                        this.$refs[\"neuronPanel\"].neuronPicked(info[0]);\r\n                    }\r\n                    else {\r\n                        // long touch\r\n                        this.rightClickMaterialDialogOpen = true;\r\n                        this.rightClickSelectedNeuron = info[0].neuron;\r\n                    }\r\n                }\r\n            }, 200);\r\n        },\r\n        /**\r\n         * save all neuronConfigs as a json file\r\n         */\r\n        saveConfigJson() {\r\n            try {\r\n                var isFileSaverSupported = !!new Blob;\r\n            } catch (e) {\r\n                this.$store.commit(\"alert\", {\r\n                    content: this.$t(\"m.a.browserVersionTooOld\")\r\n                });\r\n            }\r\n            var outputFile = {};\r\n            outputFile.useZip = this.useZip;\r\n            // fileList\r\n            outputFile[\"fileList\"] = this.fileList;\r\n            // aliases & groups\r\n            var outAliasDict = {};\r\n            var outGroupDict = {};\r\n            var outMaterialDict = {};\r\n            this.groupList.forEach(groupName => {\r\n                    outGroupDict[groupName] = [];\r\n            })\r\n            this.neuronList.forEach(item => {\r\n                var gr = outGroupDict[item.group];\r\n                if(gr!= undefined) {\r\n                    gr.push(item.neuron.name);\r\n                }\r\n                else {\r\n                    outGroupDict[item.group] = [item.neuron.name];\r\n                }\r\n                outAliasDict[item.originalName] = item.neuron.name;\r\n                var mat = item.neuron.material;\r\n                outMaterialDict[item.neuron.name] = {\r\n                    type: mat.uniforms.type.value,\r\n                    primaryColor: \"#\" + mat.uniforms.primaryColor.value.getHexString(),\r\n                    secondaryColor: \"#\" + mat.uniforms.secondaryColor.value.getHexString(),\r\n                    shininess: mat.uniforms.shininess.value,\r\n                    visible: item.neuron.visible\r\n                }\r\n            })\r\n            outputFile[\"aliases\"] = outAliasDict;\r\n            outputFile[\"groups\"] = outGroupDict;\r\n            outputFile[\"materials\"] = outMaterialDict;\r\n            var outLightingList = [];\r\n            this.lights.forEach(light => {\r\n                outLightingList.push({\r\n                    color: \"#\" + light.color.getHexString(),\r\n                    strength: light.strength\r\n                })\r\n            });\r\n            var outCamera = {\r\n                position: this.camera.position.toArray(),\r\n                target: this.controls.target.toArray()\r\n            }\r\n            outputFile[\"scene\"] = {\r\n                background: this.bgColor,\r\n                lighting: outLightingList,\r\n                camera: outCamera\r\n            };\r\n            var outTagList = [];\r\n            this.tagList.forEach(tag => {\r\n                outTagList.push({\r\n                    position: tag.position,\r\n                    text: tag.text,\r\n                    fontItalic: tag.fontItalic,\r\n                    fontBold: tag.fontBold,\r\n                    fontSize: tag.fontSize,\r\n                    textAlign: tag.textAlign,\r\n                    fontColor: tag.fontColor,\r\n                    hasBorder: tag.hasBorder,\r\n                    borderColor: tag.borderColor,\r\n                    borderRadius: tag.borderRadius,\r\n                    borderThickness: tag.borderThickness,\r\n                    hasBackground: tag.hasBackground,\r\n                    backgroundColor: tag.backgroundColor\r\n                })\r\n            })\r\n            outputFile[\"tags\"] = outTagList;\r\n            var outputJson = JSON.stringify(outputFile, null, 4);\r\n            download(outputJson, \"config.json\", \"text/plain\");\r\n        },\r\n        saveScreenshot() {\r\n            var strMime = \"image/jpeg\";\r\n            var imgData = this.renderer.domElement.toDataURL(strMime);\r\n            var link = document.createElement(\"a\");\r\n            link.download = \"neuron.png\";\r\n            link.href = imgData;\r\n            link.click();\r\n        },\r\n        togglePanel(e) {\r\n            this.panelsOpen = !this.panelsOpen;\r\n            e.target.blur();\r\n        }\r\n    },\r\n    beforeDestroy() {\r\n        window.removeEventListener(\"resize\", this.render);\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.canvas-container {\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    /* border: 1px solid black; */\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: stretch;\r\n    overflow: hidden;\r\n}\r\n.canvas-box {\r\n    height: 100%;\r\n    width: 100%;\r\n    position: relative;\r\n    display: flex;\r\n}\r\n.pointer-tag {\r\n    display: flex;\r\n    position: absolute;\r\n    top: 30px;\r\n    left: 30px;\r\n    z-index: 1;\r\n    color: #ffffff;\r\n    user-select: none;\r\n    -moz-user-select: -moz-none;\r\n    -webkit-user-select: none;\r\n    -ms-user-select: none;\r\n}\r\n.panels-container {\r\n    position: absolute;\r\n    top: 20px;\r\n    right: 20px;\r\n    width: min-content;\r\n    height: min-content;\r\n    max-height: calc(100% - 40px);\r\n    overflow: hidden;\r\n    overflow-y: scroll;\r\n    transition: 200ms;\r\n}\r\n.panels-container-mobile {\r\n    width: calc(100% - 40px);\r\n}\r\n.panels-container::-webkit-scrollbar {\r\n    background: #aaa;\r\n    width: 5px;\r\n}\r\n.panels-container::-webkit-scrollbar-thumb\r\n{\r\n    background-color:#333;\r\n}\r\n.panels-wrapper {\r\n    width: 360px;\r\n}\r\n.panels-container-mobile >>> .panels-wrapper {\r\n    width: 100%;\r\n}\r\n/* .panels-container-mobile >>> .v-expansion-panel {\r\n    background: #ffffff60 !important;\r\n}\r\n.panels-container-mobile >>> .v-expansion-panel-content {\r\n    background: none !important;\r\n}\r\n.panels-container-mobile >>> .neuron-table {\r\n    background: none !important;\r\n} */\r\n\r\n.panels-toggle-btn {\r\n    position: absolute;\r\n    top: 30px;\r\n    right: 30px;\r\n    z-index: 190;\r\n}\r\n</style>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MyCanvas.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MyCanvas.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./MyCanvas.vue?vue&type=template&id=571896aa&scoped=true&\"\nimport script from \"./MyCanvas.vue?vue&type=script&lang=js&\"\nexport * from \"./MyCanvas.vue?vue&type=script&lang=js&\"\nimport style0 from \"./MyCanvas.vue?vue&type=style&index=0&id=571896aa&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"571896aa\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBtn } from 'vuetify/lib/components/VBtn';\nimport { VCard } from 'vuetify/lib/components/VCard';\nimport { VFlex } from 'vuetify/lib/components/VGrid';\nimport { VIcon } from 'vuetify/lib/components/VIcon';\ninstallComponents(component, {VBtn,VCard,VFlex,VIcon})\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./MyCanvas.vue?vue&type=style&index=0&id=571896aa&scoped=true&lang=css&\""],"sourceRoot":""}